[toc]

## 协程

> 协程让异步同步化，消除回调地狱
>
> 协程最核心的点是，函数或者一段程序能够挂起，稍后再从挂起的位置恢复

### 协程的挂起和恢复

> 常规协程的基础操作包括：invoke（或call）和return，协程新增了suspend和resume：
>
> suspend：也成为挂起或暂停，用于暂停执行当前线程，并保存所有局部变量
>
> resume：用于让已暂停的协程从其暂停处继续执行

- 原生创建协程的方法

  ```kotlin
  val continuation = suspend {
              5
          }.createCoroutine(object : Continuation<Int> {
              override val context: CoroutineContext
                  get() = EmptyCoroutineContext
  
              override fun resumeWith(result: Result<Int>) {
                  Log.d("west" ,"Continuation $result")
              }
          })
          continuation.resume(Unit)
  ```

### 堆栈中的函数调用流程

- getUser()

  ````kotlin
  private suspend fun getUser() {
      val user = get()
      show(user)
  }
  
  private suspend fun get() = withContext(Dispatchers.IO) {
      userServiceApi.getUser("Xxx")
  }
  ````

  1. 执行getUser()，栈帧会出现在主线程的栈中
  2. 执行get()，getUser()被挂起
  3. 执行withContext()，get()被挂起
  4. Dispatcher.IO执行完成后，返回值给get()，get()被恢复
  5. get()返回值给getUser()，getUser()被恢复
  
- 问：协程挂起点保存在哪里？

### 协程的调度器

> 所有的协程都必须在调度器中运行，即使它们在主线程上也一样

Dispatcher.Main

> android上的主线程，用来处理一些UI交互和轻量级任务。
>
> - 调用suspend函数
> - 调用ui函数
> - 更新liveData

Dispatcher.IO

> 非主线程
>
> 专为磁盘和网络进行了优化
>
> - 读写数据库
> - 文件读写
> - 网络请求

Dispatcher.Default

> 非主线程
>
> 专为CPU密集型任务进行了优化
>
> - 数组排序
> - JSON数据解析
> - 处理差异判断

任务泄露

> 当某个协程任务丢失，无法跟踪，会导致内存、CPU、磁盘等资源浪费，甚至发送一个无用的网络请求，这种情况称为**任务泄露**
>
> 为了能够避免协程泄露，Kotlin引入了**结构化并发机制**

### 结构化并发

> 使用结构化并发可以做到：
>
> 1. 取消任务，当某个任务不再需要时，取消它
> 2. 跟踪任务，当任务正在执行时，跟踪它
> 3. 发出错误信号，当协程失败时，发出错误信号表明有错误发生

- testSync()

  ```kotlin
  @Test
      fun testSync() = runBlocking {
          val millsTime = measureTimeMillis {
              val one = doOne()
              val two = doTwo()
              println("the result : ${one + two}")
          }
          println("time $millsTime")
      }
  
      private suspend fun doOne() : Int {
          delay(1000)
          return 1
      }
  
      private suspend fun doTwo() : Int {
          delay(1000)
          return 2
      }
  
  执行结果：
  the result : 3
  time 2024
  ```

- testAsync()

  ```kotlin
  @Test
      fun testAsync() = runBlocking {
          val millsTime = measureTimeMillis {
              val one = async { doOne() }
              val two = async { doTwo() }
              println("the result : ${one.await() + two.await()}")
          }
          println("time $millsTime")
      }
  
      private suspend fun doOne() : Int {
          delay(1000)
          return 1
      }
  
      private suspend fun doTwo() : Int {
          delay(1000)
          return 2
      }
  
  执行结果：
  the result : 3
  time 1020
  ```

  使用async，doOne和doTwo同时执行完才打印

- 错误示例

  ```kotlin
  val one = async { doOne() }.await()
  val two = async { doTwo() }.await()
  
  time 2045
  没有并发效果
  ```

### CoroutineScope

> 定义协程必须指定其CoroutineScope，它会跟踪所有协程，同样它还可以取消由它启动的所有协程
>
> 常用的相关API有：
> GlobalScope，生命周期是process级的，即使Activity或Fragment已经被销毁，协程仍然可以执行
>
> MainScope，在Activity中使用，可以在onDestroy()中取消协程
>
> viewModelScope，只能在viewModel中使用，绑定ViewModel生命周期
>
> lifeCycleScope，只能在Activity、Fragment里使用，会绑定Activity和Fragment的生命周期

#### MainScope

- mainScope

  ```kotlin
  // MainScope() 其实是个函数，但是特意设计为大写开头，由工厂创建对象
  val mainScope = MainScope()
  
  // 只要mainScope取消，内部启动的所有协程都会取消
  mainScope.launch {
              val user = getUser()
              log(user.name)
          }
  
  override fun onDestroy() {
          super.onDestroy()
      	// 取消
          mainScope.cancel()
      }
  ```

  如果mainScope还没执行完，调用cancel()会抛出异常

  ```
  kotlinx.coroutines.JobCancellationException: Job was cancelled; job=SupervisorJobImpl{Cancelling}@131d0d4
  ```

- 委托写法

  ```kotlin
  class MainActivity : AppCompatActivity(), CoroutineScope by MainScope(){
  
       override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          setContentView(R.layout.activity_main)
  
           // 直接launch
          launch {
              delay(100000)
          }
      }
  
      override fun onDestroy() {
          super.onDestroy()
          // 直接cancel
          cancel()
      }
  }
  ```

### launch和async返回值比较

> launch：返回一个Job且不带任何结果值
>
> async：返回一个Deferred，Deferred也是一个Job，可以使用await()在一个延期的值上得到结果

- testCoroutineBuilder

  ````kotlin
  @Test
      fun testCoroutineBuilder() {
          runBlocking {
  
              // Job
              val job1 = launch {
                  delay(2000)
                  println("job1 finish")
              }
  
              // Deferred(推迟)
              val job2 = async {
                  delay(2000)
                  println("job2 finish")
              }
  
              println("job2 result ${job2.await()}")
          }
      }
  ````

  runBlocking会阻塞线程，等待子协程执行完成，主线程才能退出

### join和await协程等待作业

- testCoroutineJoin

  ```kotlin
   @Test
      fun testCoroutineJoin() {
          runBlocking {
              val job1 = launch {
                  delay(2000)
                  println("one")
              }
              // join():job1执行完成后才启动job2、job3
              // 如果不加入join()，job1,job2,job3可并发执行
              job1.join()
              val job2 = launch {
                  delay(2000)
                  println("two")
              }
              val job3 = launch {
                  delay(2000)
                  println("three")
              }
          }
      }
  ```

- testCoroutineAwait

  ```kotlin
  @Test
      fun testCoroutineAwait() {
          runBlocking {
              val job1 = async {
                  delay(2000)
                  println("one")
              }
              // 同上，调用job1.await()，job1执行完成，得到返回结果后，才执行job2，job3
              job1.await()
              val job2 = async {
                  delay(2000)
                  println("two")
              }
              val job3 = async {
                  delay(2000)
                  println("three")
              }
          }
      }
  ```
  
  假如不调用job1.await()
  
- testCoroutineAwait

  ```kotlin
          runBlocking {
              val start = System.currentTimeMillis()
              val job1 = async {
                  delay(2000)
                  Log.d("west", "time2 ：${System.currentTimeMillis()-start}")
              }
              // 同上，调用job1.await()，job1执行完成，得到发挥结果后，才执行job2，job3
              val job2 = async {
                  delay(2000)
                  Log.d("west", "time3 ：${System.currentTimeMillis()-start}")
              }
              val job3 = async {
                  delay(2000)
                  Log.d("west", "time4 ：${System.currentTimeMillis()-start}")
              }
              val end = System.currentTimeMillis()
              Log.d("west", "time1 ：${end-start}")
          }
  ```

  结果：

  D/west: time1 ：4
  D/west: time2 ：2009
  D/west: time3 ：2010
  D/west: time4 ：2010

### 协程的启动模式

#### DEFAULT

> 协程创建后，立即开始调度（不代表立即执行），在调度前如果协程被取消，其将直接进入取消响应的状态

- default

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = launch(start = CoroutineStart.DEFAULT) {
              delay(10000)
              Log.d("west", "job cancel")
          }
          delay(1000)
          job.cancel()
      }
  
  D/west: time 1020
  ```

  启动模式为CoroutineStart.DEFAULT，cancel()时会立刻取消协程

#### ATOMIC

> 协程创建后，立刻开始调度，协程执行第一个挂起点之前不响应取消

- atomic

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = launch(start = CoroutineStart.ATOMIC) {
              /**
               * 重要代码
               */
              delay(10000)
              Log.d("west", "job cancel")
          }
          delay(1000)
          job.cancel()
      }
  ```

  delay()为第一个挂起点，如果启动模式为CoroutineStart.ATOMIC，协程执行到delay()之前调用job.cancel()，不响应取消状态。

  这样做的意义：重要代码必须执行，不能被cancel打断

#### LAZY

> 只有协程被需要时，包括主动调用协程的start、join或者await等函数时才会开始调度，如果调度前就被取消，那么该协程将直接进入异常结束状态

- lazy

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = async(start = CoroutineStart.LAZY) {
              29
          }
          // 。。。计算
          job.await()
      }
  ```

  调用job.await()时，才开始调度协程	

#### UNDISPATCHERD

>  协程创建后立即进入当前函数调用栈中执行，直到遇到第一个正真挂起的点

- undispatched

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = async(context = Dispatchers.IO, start = CoroutineStart.UNDISPATCHED) {
              Log.d("west", "thread ${Thread.currentThread().name}")
          }
      }
  ```

  当前函数调用栈是主线程，Log.d("west", "thread ${Thread.currentThread().name}")也会在主线程执行，直到遇到第一个挂起点才转为IO线程

### 协程的作用域构建器

> - coroutineScope和runBlocking
>
> 1. runBlocking是常规函数（不是suspend），coroutineScope是挂起函数
> 2. 它们都会等待其协程体以及所有子协程结束，主要区别在于runBlocking方法会阻塞当前线程来等待，而coroutineScope只是挂起，会释放底层线程用于其他用途。

> - coroutineScope和supervisorScope
>
> 1. coroutineScope：一个协程失败了，所有兄弟协程也会取消
> 2. supervisorScope：一个协程失败了，不会影响其他兄弟协程
>
> ```kotlin
> fun testCoroutineAwait() = runBlocking {
>         coroutineScope {
>             val job1 = launch {
>                 delay(1000)
>                 Log.d("west", "job1 finish")
>                 throw IllegalArgumentException()
>             }
>             val job2 = async {
>                 delay(2000)
>                 Log.d("west", "job2 finish")
>             }
>         }
>     }
> 
> 2021-12-09 23:14:51.683 18112-18150/com.henyiwu.myapplication D/west: job1 finish
>     --------- beginning of crash
> ```
>
> ```kotlin
>     fun testCoroutineAwait() = runBlocking {
>         supervisorScope {
> 
>             val job2 = launch {
>                 delay(2000)
>                 Log.d("west", "job2 finish")
>             }
> 
>             val job1 = async {
>                 delay(1000)
>                 Log.d("west", "job1 finish")
>                 throw IllegalArgumentException()
>             }
>         }
>     }
> 
> 2021-12-09 23:30:12.354 20459-20498/com.henyiwu.myapplication D/west: job1 finish
> 2021-12-09 23:30:13.351 20459-20498/com.henyiwu.myapplication D/west: job2 finish
> ```

### Job

> - 对于每一个创建的协程，通过launch或者async，都会返回一个实力，这个实例是协程的唯一标识，并且负责管理协程的生命周期。
>
> - 一个任务可以包含一些列的状态：新创建（New）、活跃（Active）、完成中（Completing）、已完成（Completed）、取消中（Cancelling）和已取消（Cancelled）。虽然我们无法直接访问这些状态，但是我们可以访问Job的属性：isAlive、isCancelled和isCompleted
>
>   ```
>   job.isActive
>   job.isCompleted
>   job.isCancelled
>   ```

#### Job的生命周期

> 如果协程处于活跃状态，协程运行出错或者调用job.cancel()都会将当前任务置为取消中，当所有子协程都完成后，协程会进入已取消的状态，此时isCompleted = true

### 协程的取消

> - 取消作用域会取消它的子协程
> - 被取消的子协程不会影响其他兄弟协程
> - 协程通过抛出一个特殊异常CancellationException来处理取消操作
> - 所有kotlin.coroutines中的挂起函数（withContext、delay等）都是可以取消的

- test

  ```kotlin
  fun testScopeCancel() = runBlocking {
          val scope = CoroutineScope(Dispatchers.Default)
          scope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
          scope.launch {
              delay(1000)
              Log.d("west", "job2")
          }
          delay(100)
          scope.cancel()
          delay(1000)
      }
  
  // 无输出结果
  ```

#### 被取消的子协程不会影响其余兄弟协程

- test

  ```kotlin
      fun testBrotherCancel() = runBlocking {
          val scope = CoroutineScope(Dispatchers.Default)
          val job1 = scope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
          val job2 = scope.launch {
              delay(1000)
              Log.d("west", "job2")
          }
          delay(100)
          job1.cancel()
          delay(1000)
      }
  
  // 2021-12-11 10:42:57.747 23248-23312/com.henyiwu.myapplication D/west: job2
  ```

- test

  ```kotlin
      @Test
      fun testCancellationCancel() = runBlocking {
          val job1 = GlobalScope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
      }
  
  // 无打印结果，runBlocking不会等待GlobalScope执行完成，GlobalScope有自己的上下文
  ```

#### 协程的取消异常

- testCancellationCancel

  ```kotlin
      fun testCancellationCancel() = runBlocking {
          val job1 = GlobalScope.launch {
              try {
                  delay(1000)
                  Log.d("west", "job1")
              } catch (e: Exception) {
                  Log.d("west", "e: $e")
              }
          }
          delay(100)
          job1.cancel(CancellationException(("异常了")))
          job1.join()
      }
      
      // Failure(java.util.concurrent.CancellationException: 异常了)
  ```

#### CPU密集型任务取消

> - isActive是一个可以被使用的CoroutineScope中的扩展属性，检查Job是否处于活跃状态
> - ensureActive()，如果job处于非活跃状态，这个方法会抛出异常
> - yield函数会检查所在协程的状态，如果已经取消，则抛出CancellationException予以响应。此外，它还会尝试让出线程的执行权，给其他协程提供机会。

- test

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5) {
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
      
  Job: Im sleeping 0
  Job: Im sleeping 1
  Job: Im sleeping 2
  Job: Im sleeping 3
  im tried of waiting
  Job: Im sleeping 4
  main: Now i can quit
  ```

  CPU密集型的，无法直接cancel()，可以改为

- isActive

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5 && isActive) {
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
      
  Job: Im sleeping 0
  Job: Im sleeping 1
  Job: Im sleeping 2
  Job: Im sleeping 3
  im tried of waiting
  main: Now i can quit
  ```

  因为调用cancel()时，job的isActive状态会转为false

- 或者使用ensureActive()

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5) {
                  ensureActive()
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
  ```

#### 协程取消的副作用

> 协程取消后，后续代码不会执行，如果后续代码是释放资源，可能造成内存泄漏

- 处理

  ```kotlin
      @Test
      fun testSet() = runBlocking {
          val job = launch {
              try {
                  repeat(1000) {
                      println("repeat $it")
                      delay(1000)
                  }
              } catch (e: Exception) {
                  println("exception : $e")
              }
          }
          delay(1400)
          println("退出")
          job.cancelAndJoin()
      }
  
  repeat 0
  repeat 1
  退出
  exception : kotlinx.coroutines.JobCancellationException: Job was cancelled; job="coroutine#2":StandaloneCoroutine{Cancelling}@61230f6a
  ```

  应该在finally中处理释放资源