[toc]

## 协程

### 协程的挂起和恢复

> 常规协程的基础操作包括：invoke（或call）和return，协程新增了suspend和resume：
>
> suspend：也成为挂起或暂停，用于暂停执行当前线程，并保存所有局部变量
>
> resume：用于让已暂停的协程从其暂停处继续执行

- 原生创建协程的方法

  ```kotlin
  val continuation = suspend {
              5
          }.createCoroutine(object : Continuation<Int> {
              override val context: CoroutineContext
                  get() = EmptyCoroutineContext
  
              override fun resumeWith(result: Result<Int>) {
                  Log.d("west" ,"Continuation $result")
              }
          })
          continuation.resume(Unit)
  ```

### 协程的调度器

> 所有的协程都必须在调度器中运行，即使它们在主线程上也一样

Dispatcher.Main

> android上的主线程，用来处理一些UI交互和轻量级任务。
>
> - 调用suspend函数
> - 调用ui函数
> - 更新liveData

Dispatcher.IO

> 非主线程
>
> 专为磁盘和网络进行了优化
>
> - 读写数据库
> - 文件读写
> - 网络请求

Dispatcher.Default

> 非主线程
>
> 专为CPU密集型任务进行了优化
>
> - 数组排序
> - JSON数据解析
> - 处理差异判断

任务泄露

> 当某个协程任务丢失，无法跟踪，会导致内存、CPU、磁盘等资源浪费，甚至发送一个无用的网络请求，这种情况称为**任务泄露**
>
> 为了能够避免协程泄露，Kotlin引入了**结构化并发机制**

### 结构化并发

> 使用结构化并发可以做到：
>
> 1. 取消任务，当某个任务不再需要时，取消它
> 2. 跟踪任务，当任务正在执行时，跟踪它
> 3. 发出错误信号，当协程失败时，发出错误信号表明有错误发生

### CoroutineScope

> 定义协程必须指定其CoroutineScope，它会跟踪所有协程，同样它还可以取消由它启动的所有协程
>
> 常用的相关API有：
> GlobalScope，生命周期是process级的，即使Activity或Fragment已经被销毁，协程仍然可以执行
>
> MainScope，在Activity中使用，可以在onDestroy()中取消协程
>
> viewModelScope，只能在viewModel中使用，绑定ViewModel生命周期
>
> lifeCycleScope，只能在Activity、Fragment里使用，会绑定Activity和Fragment的生命周期

#### MainScope

- mainScope

  ```kotlin
  // MainScope() 其实是个函数，但是特意设计为大写开头，由工厂创建对象
  val mainScope = MainScope()
  
  // 只要mainScope取消，内部启动的所有协程都会取消
  mainScope.launch {
              val user = getUser()
              log(user.name)
          }
  
  override fun onDestroy() {
          super.onDestroy()
      	// 取消
          mainScope.cancel()
      }
  ```

  如果mainScope还没执行完，调用cancel()会抛出异常

  ```
  kotlinx.coroutines.JobCancellationException: Job was cancelled; job=SupervisorJobImpl{Cancelling}@131d0d4
  ```

- 委托写法

  ```kotlin
  class MainActivity : AppCompatActivity(), CoroutineScope by MainScope(){
  
       override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          setContentView(R.layout.activity_main)
  
           // 直接launch
          launch {
              delay(100000)
          }
      }
  
      override fun onDestroy() {
          super.onDestroy()
          // 直接cancel
          cancel()
      }
  }
  ```