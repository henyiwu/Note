
[toc]

## 协程

> 协程让异步同步化，消除回调地狱
>
> 协程最核心的点是，函数或者一段程序能够挂起，稍后再从挂起的位置恢复

### 协程的挂起和恢复

> 常规协程的基础操作包括：invoke（或call）和return，协程新增了suspend和resume：
>
> suspend：也成为挂起或暂停，用于暂停执行当前线程，并保存所有局部变量
>
> resume：用于让已暂停的协程从其暂停处继续执行

- 原生创建协程的方法

  ```kotlin
  val continuation = suspend {
              5
          }.createCoroutine(object : Continuation<Int> {
              override val context: CoroutineContext
                  get() = EmptyCoroutineContext
  
              override fun resumeWith(result: Result<Int>) {
                  Log.d("west" ,"Continuation $result")
              }
          })
          continuation.resume(Unit)
  ```

### 堆栈中的函数调用流程

- getUser()

  ````kotlin
  private suspend fun getUser() {
      val user = get()
      show(user)
  }
  
  private suspend fun get() = withContext(Dispatchers.IO) {
      userServiceApi.getUser("Xxx")
  }
  ````

  1. 执行getUser()，栈帧会出现在主线程的栈中
  2. 执行get()，getUser()被挂起
  3. 执行withContext()，get()被挂起
  4. Dispatcher.IO执行完成后，返回值给get()，get()被恢复
  5. get()返回值给getUser()，getUser()被恢复
  
- 问：协程挂起点保存在哪里？

### 协程的调度器

> 所有的协程都必须在调度器中运行，即使它们在主线程上也一样

Dispatcher.Main

> android上的主线程，用来处理一些UI交互和轻量级任务。
>
> - 调用suspend函数
> - 调用ui函数
> - 更新liveData

Dispatcher.IO

> 非主线程
>
> 专为磁盘和网络进行了优化
>
> - 读写数据库
> - 文件读写
> - 网络请求

Dispatcher.Default

> 非主线程
>
> 专为CPU密集型任务进行了优化
>
> - 数组排序
> - JSON数据解析
> - 处理差异判断

任务泄露

> 当某个协程任务丢失，无法跟踪，会导致内存、CPU、磁盘等资源浪费，甚至发送一个无用的网络请求，这种情况称为**任务泄露**
>
> 为了能够避免协程泄露，Kotlin引入了**结构化并发机制**

### 结构化并发

> 使用结构化并发可以做到：
>
> 1. 取消任务，当某个任务不再需要时，取消它
> 2. 跟踪任务，当任务正在执行时，跟踪它
> 3. 发出错误信号，当协程失败时，发出错误信号表明有错误发生

- testSync()

  ```kotlin
  @Test
      fun testSync() = runBlocking {
          val millsTime = measureTimeMillis {
              val one = doOne()
              val two = doTwo()
              println("the result : ${one + two}")
          }
          println("time $millsTime")
      }
  
      private suspend fun doOne() : Int {
          delay(1000)
          return 1
      }
  
      private suspend fun doTwo() : Int {
          delay(1000)
          return 2
      }
  
  执行结果：
  the result : 3
  time 2024
  ```

- testAsync()

  ```kotlin
  @Test
      fun testAsync() = runBlocking {
          val millsTime = measureTimeMillis {
              val one = async { doOne() }
              val two = async { doTwo() }
              println("the result : ${one.await() + two.await()}")
          }
          println("time $millsTime")
      }
  
      private suspend fun doOne() : Int {
          delay(1000)
          return 1
      }
  
      private suspend fun doTwo() : Int {
          delay(1000)
          return 2
      }
  
  执行结果：
  the result : 3
  time 1020
  ```

  使用async，doOne和doTwo同时执行完才打印

- 错误示例

  ```kotlin
  val one = async { doOne() }.await()
  val two = async { doTwo() }.await()
  
  time 2045
  没有并发效果
  ```

### CoroutineScope

> 定义协程必须指定其CoroutineScope，它会跟踪所有协程，同样它还可以取消由它启动的所有协程
>
> 常用的相关API有：
> GlobalScope，生命周期是process级的，即使Activity或Fragment已经被销毁，协程仍然可以执行
>
> MainScope，在Activity中使用，可以在onDestroy()中取消协程
>
> viewModelScope，只能在viewModel中使用，绑定ViewModel生命周期
>
> lifeCycleScope，只能在Activity、Fragment里使用，会绑定Activity和Fragment的生命周期

#### MainScope

- mainScope

  ```kotlin
  // MainScope() 其实是个函数，但是特意设计为大写开头，由工厂创建对象
  val mainScope = MainScope()
  
  // 只要mainScope取消，内部启动的所有协程都会取消
  mainScope.launch {
              val user = getUser()
              log(user.name)
          }
  
  override fun onDestroy() {
          super.onDestroy()
      	// 取消
          mainScope.cancel()
      }
  ```

  如果mainScope还没执行完，调用cancel()会抛出异常

  ```
  kotlinx.coroutines.JobCancellationException: Job was cancelled; job=SupervisorJobImpl{Cancelling}@131d0d4
  ```

- 委托写法

  ```kotlin
  class MainActivity : AppCompatActivity(), CoroutineScope by MainScope(){
  
       override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          setContentView(R.layout.activity_main)
  
           // 直接launch
          launch {
              delay(100000)
          }
      }
  
      override fun onDestroy() {
          super.onDestroy()
          // 直接cancel
          cancel()
      }
  }
  ```

### launch和async返回值比较

> launch：返回一个Job且不带任何结果值
>
> async：返回一个Deferred，Deferred也是一个Job，可以使用await()在一个延期的值上得到结果

- testCoroutineBuilder

  ````kotlin
  @Test
      fun testCoroutineBuilder() {
          runBlocking {
  
              // Job
              val job1 = launch {
                  delay(2000)
                  println("job1 finish")
              }
  
              // Deferred(推迟)
              val job2 = async {
                  delay(2000)
                  println("job2 finish")
              }
  
              println("job2 result ${job2.await()}")
          }
      }
  ````

  runBlocking会阻塞线程，等待子协程执行完成，主线程才能退出

### join和await协程等待作业

- testCoroutineJoin

  ```kotlin
   @Test
      fun testCoroutineJoin() {
          runBlocking {
              val job1 = launch {
                  delay(2000)
                  println("one")
              }
              // join():job1执行完成后才启动job2、job3
              // 如果不加入join()，job1,job2,job3可并发执行
              job1.join()
              val job2 = launch {
                  delay(2000)
                  println("two")
              }
              val job3 = launch {
                  delay(2000)
                  println("three")
              }
          }
      }
  ```

- testCoroutineAwait

  ```kotlin
  @Test
      fun testCoroutineAwait() {
          runBlocking {
              val job1 = async {
                  delay(2000)
                  println("one")
              }
              // 同上，调用job1.await()，job1执行完成，得到返回结果后，才执行job2，job3
              job1.await()
              val job2 = async {
                  delay(2000)
                  println("two")
              }
              val job3 = async {
                  delay(2000)
                  println("three")
              }
          }
      }
  ```
  
  假如不调用job1.await()
  
- testCoroutineAwait

  ```kotlin
          runBlocking {
              val start = System.currentTimeMillis()
              val job1 = async {
                  delay(2000)
                  Log.d("west", "time2 ：${System.currentTimeMillis()-start}")
              }
              // 同上，调用job1.await()，job1执行完成，得到发挥结果后，才执行job2，job3
              val job2 = async {
                  delay(2000)
                  Log.d("west", "time3 ：${System.currentTimeMillis()-start}")
              }
              val job3 = async {
                  delay(2000)
                  Log.d("west", "time4 ：${System.currentTimeMillis()-start}")
              }
              val end = System.currentTimeMillis()
              Log.d("west", "time1 ：${end-start}")
          }
  ```

  结果：

  D/west: time1 ：4
  D/west: time2 ：2009
  D/west: time3 ：2010
  D/west: time4 ：2010

### 协程的启动模式

#### DEFAULT

> 协程创建后，立即开始调度（不代表立即执行），在调度前如果协程被取消，其将直接进入取消响应的状态

- default

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = launch(start = CoroutineStart.DEFAULT) {
              delay(10000)
              Log.d("west", "job cancel")
          }
          delay(1000)
          job.cancel()
      }
  
  D/west: time 1020
  ```

  启动模式为CoroutineStart.DEFAULT，cancel()时会立刻取消协程

#### ATOMIC

> 协程创建后，立刻开始调度，协程执行第一个挂起点之前不响应取消

- atomic

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = launch(start = CoroutineStart.ATOMIC) {
              /**
               * 重要代码
               */
              delay(10000)
              Log.d("west", "job cancel")
          }
          delay(1000)
          job.cancel()
      }
  ```

  delay()为第一个挂起点，如果启动模式为CoroutineStart.ATOMIC，协程执行到delay()之前调用job.cancel()，不响应取消状态。

  这样做的意义：重要代码必须执行，不能被cancel打断

#### LAZY

> 只有协程被需要时，包括主动调用协程的start、join或者await等函数时才会开始调度，如果调度前就被取消，那么该协程将直接进入异常结束状态

- lazy

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = async(start = CoroutineStart.LAZY) {
              29
          }
          // 。。。计算
          job.await()
      }
  ```

  调用job.await()时，才开始调度协程	

#### UNDISPATCHERD

>  协程创建后立即进入当前函数调用栈中执行，直到遇到第一个正真挂起的点

- undispatched

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = async(context = Dispatchers.IO, start = CoroutineStart.UNDISPATCHED) {
              Log.d("west", "thread ${Thread.currentThread().name}")
          }
      }
  ```

  当前函数调用栈是主线程，Log.d("west", "thread ${Thread.currentThread().name}")也会在主线程执行，直到遇到第一个挂起点才转为IO线程

### 协程的作用域构建器

> - coroutineScope和runBlocking
>
> 1. runBlocking是常规函数（不是suspend），coroutineScope是挂起函数
> 2. 它们都会等待其协程体以及所有子协程结束，主要区别在于runBlocking方法会阻塞当前线程来等待，而coroutineScope只是挂起，会释放底层线程用于其他用途。

> - coroutineScope和supervisorScope
>
> 1. coroutineScope：一个协程失败了，所有兄弟协程也会取消
> 2. supervisorScope：一个协程失败了，不会影响其他兄弟协程
>
> ```kotlin
> fun testCoroutineAwait() = runBlocking {
>         coroutineScope {
>             val job1 = launch {
>                 delay(1000)
>                 Log.d("west", "job1 finish")
>                 throw IllegalArgumentException()
>             }
>             val job2 = async {
>                 delay(2000)
>                 Log.d("west", "job2 finish")
>             }
>         }
>     }
> 
> 2021-12-09 23:14:51.683 18112-18150/com.henyiwu.myapplication D/west: job1 finish
>     --------- beginning of crash
> ```
>
> ```kotlin
>     fun testCoroutineAwait() = runBlocking {
>         supervisorScope {
> 
>             val job2 = launch {
>                 delay(2000)
>                 Log.d("west", "job2 finish")
>             }
> 
>             val job1 = async {
>                 delay(1000)
>                 Log.d("west", "job1 finish")
>                 throw IllegalArgumentException()
>             }
>         }
>     }
> 
> 2021-12-09 23:30:12.354 20459-20498/com.henyiwu.myapplication D/west: job1 finish
> 2021-12-09 23:30:13.351 20459-20498/com.henyiwu.myapplication D/west: job2 finish
> ```

### Job

> - 对于每一个创建的协程，通过launch或者async，都会返回一个实力，这个实例是协程的唯一标识，并且负责管理协程的生命周期。
>
> - 一个任务可以包含一些列的状态：新创建（New）、活跃（Active）、完成中（Completing）、已完成（Completed）、取消中（Cancelling）和已取消（Cancelled）。虽然我们无法直接访问这些状态，但是我们可以访问Job的属性：isAlive、isCancelled和isCompleted
>
>   ```
>   job.isActive
>   job.isCompleted
>   job.isCancelled
>   ```

#### Job的生命周期

> 如果协程处于活跃状态，协程运行出错或者调用job.cancel()都会将当前任务置为取消中，当所有子协程都完成后，协程会进入已取消的状态，此时isCompleted = true

### 协程的取消

> - 取消作用域会取消它的子协程
> - 被取消的子协程不会影响其他兄弟协程
> - 协程通过抛出一个特殊异常CancellationException来处理取消操作
> - 所有kotlin.coroutines中的挂起函数（withContext、delay等）都是可以取消的

- test

  ```kotlin
  fun testScopeCancel() = runBlocking {
          val scope = CoroutineScope(Dispatchers.Default)
          scope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
          scope.launch {
              delay(1000)
              Log.d("west", "job2")
          }
          delay(100)
          scope.cancel()
          delay(1000)
      }
  
  // 无输出结果
  ```

#### 被取消的子协程不会影响其余兄弟协程

- test

  ```kotlin
      fun testBrotherCancel() = runBlocking {
          val scope = CoroutineScope(Dispatchers.Default)
          val job1 = scope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
          val job2 = scope.launch {
              delay(1000)
              Log.d("west", "job2")
          }
          delay(100)
          job1.cancel()
          delay(1000)
      }
  
  // 2021-12-11 10:42:57.747 23248-23312/com.henyiwu.myapplication D/west: job2
  ```

- test

  ```kotlin
      @Test
      fun testCancellationCancel() = runBlocking {
          val job1 = GlobalScope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
      }
  
  // 无打印结果，runBlocking不会等待GlobalScope执行完成，GlobalScope有自己的上下文
  ```

#### 协程的取消异常

- testCancellationCancel

  ```kotlin
      fun testCancellationCancel() = runBlocking {
          val job1 = GlobalScope.launch {
              try {
                  delay(1000)
                  Log.d("west", "job1")
              } catch (e: Exception) {
                  Log.d("west", "e: $e")
              }
          }
          delay(100)
          job1.cancel(CancellationException(("异常了")))
          job1.join()
      }
      
      // Failure(java.util.concurrent.CancellationException: 异常了)
  ```

#### CPU密集型任务取消

> - isActive是一个可以被使用的CoroutineScope中的扩展属性，检查Job是否处于活跃状态
> - ensureActive()，如果job处于非活跃状态，这个方法会抛出异常
> - yield函数会检查所在协程的状态，如果已经取消，则抛出CancellationException予以响应。此外，它还会尝试让出线程的执行权，给其他协程提供机会。

- test

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5) {
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
      
  Job: Im sleeping 0
  Job: Im sleeping 1
  Job: Im sleeping 2
  Job: Im sleeping 3
  im tried of waiting
  Job: Im sleeping 4
  main: Now i can quit
  ```

  CPU密集型的，无法直接cancel()，可以改为

- isActive

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5 && isActive) {
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
      
  Job: Im sleeping 0
  Job: Im sleeping 1
  Job: Im sleeping 2
  Job: Im sleeping 3
  im tried of waiting
  main: Now i can quit
  ```

  因为调用cancel()时，job的isActive状态会转为false

- 或者使用ensureActive()

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5) {
                  ensureActive()
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
  ```

#### 协程取消的副作用

> 协程取消后，后续代码不会执行，如果后续代码是释放资源，可能造成内存泄漏

- 处理

  ```kotlin
      @Test
      fun testSet() = runBlocking {
          val job = launch {
              try {
                  repeat(1000) {
                      println("repeat $it")
                      delay(1000)
                  }
              } catch (e: Exception) {
                  println("exception : $e")
              }
          }
          delay(1400)
          println("退出")
          job.cancelAndJoin()
      }
  
  repeat 0
  repeat 1
  退出
  exception : kotlinx.coroutines.JobCancellationException: Job was cancelled; job="coroutine#2":StandaloneCoroutine{Cancelling}@61230f6a
  ```

  应该在finally中处理释放资源

#### 不能取消的任务

> - 处于取消状态中的协程不能够挂起（运行不能取消的代码），当协程被取消后需要调用挂起函数，我们需要将清理任务放至在NonCancellable ContinueContext中。
> - 这样会挂起运行中的代码，并保持协程的取消状态直到任务完成为止

- 可取消的协程

  ```kotlin
      @Test
      fun testNoCancellable() = runBlocking {
          val job = launch {
              try {
                  repeat(1000) { i->
                      println("job: i m sleeping $i...")
                      delay(500)
                  }
              } finally {
                  println("job i m running finally")
                  delay(1000L)
                  println("i m non-cancellable")
              }
          }
          delay(1300)
          println("i m tried of waiting")
          job.cancelAndJoin()
          println("now i m quit")
      }
  
  job: i m sleeping 0...
  job: i m sleeping 1...
  job: i m sleeping 2...
  i m tried of waiting
  job i m running finally
  now i m quit
  ```

  finally中**println("i m non-cancellable")**不会打印，job.cancel()后所有协程执行完毕，进程结束

- 不可取消的协程

  ```kotlin
      @Test
      fun testNoCancellable() = runBlocking {
          val job = launch {
              try {
                  repeat(1000) { i->
                      println("job: i m sleeping $i...")
                      delay(500)
                  }
              } finally {
                  withContext(NonCancellable) {
                      println("job i m running finally")
                      delay(5000L)
                      println("i m non-cancellable")
                  }
              }
          }
          delay(1300)
          println("i m tried of waiting")
          job.cancelAndJoin()
          println("now i m quit")
      }
  
  job: i m sleeping 0...
  job: i m sleeping 1...
  job: i m sleeping 2...
  i m tried of waiting
  job i m running finally
  i m non-cancellable
  now i m quit
  ```

  调用job.cancel()后，进入finally代码块，挂起五秒后执行println("i m non-cancellable")

####  超时任务

> - 很多情况下取消一个协程的理由是它有可能超时
> - withTimeoutOrNull通过返回null来进行超时操作，从而代替抛出一个异常

- witchTimeout

  ```kotlin
      @Test
      fun testTimeout() = runBlocking {
          val value = withTimeout(1300) {
              repeat(1000) {
                  println("job im sleeping $it")
                  delay(1000)
              }
              "Done"
          }
          println("result is $value")
      }
  
  
  job im sleeping 0
  job im sleeping 1
  
  kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
  
  	at kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:126)
  	at kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:92)
  	at kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:491)
  	at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:270)
  	at kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:68)
  	at java.base/java.lang.Thread.run(Thread.java:844)
  ```

  超时的时候withTimeout会抛异常

- withTimeoutOrNull

  ```kotlin
      @Test
      fun testTimeout() = runBlocking {
          val value = withTimeoutOrNull(1300) {
              repeat(1000) {
                  println("job im sleeping $it")
                  delay(1000)
              }
              "Done"
          }
          println("result is $value")
      }
  
  job im sleeping 0
  job im sleeping 1
  result is null
  
  Process finished with exit code 0
  ```

  超时时返回null

### 协程的上下文

> CoroutineContext是一组用于定义协程行为的元素，它由以下几项构成
>
> 1. job：控制协程的生命周期
> 2. CoroutineDispatcher：向合适的线程分发任务
> 3. CoroutineName：协程的名称，调试的时候有用
> 4. CoroutineExceptionHandler：处理未捕捉的异常

- testCoroutineContext

  ```kotlin
      @Test
      fun testCoroutineContext() = runBlocking<Unit> {
          // CoroutineContext对+进行重载
          launch(Dispatchers.Default + CoroutineName("test")) {
              println("i m working in thread $this")
          }
      }
  ```

### 协程上下文继承

> 对于新创建的协程，它的CoroutineContext会包含一个全新的Job实例，它会帮助我们控制协程的生命周期，而剩下的元素从CoroutineContext的父类继承，该父类可能是另外一个协程或者创建该协程的CoroutineScope

- testCoroutineContextThread

  ```kotlin
      @Test
      fun testCoroutineContextThread() = runBlocking {
          val scope = CoroutineScope(Job() + Dispatchers.IO + CoroutineName("test"))
          val job = scope.launch { // 1
              println("${coroutineContext.get(Job)} ${Thread.currentThread().name}")
              val result = async { // 2
                  println("${coroutineContext[Job]} ${Thread.currentThread().name}")
                  "OK"
              }.await()
          }
          job.join()
      }
  
  "test#2":StandaloneCoroutine{Active}@5ece6e2d DefaultDispatcher-worker-2 @test#2
  "test#3":DeferredCoroutine{Active}@5af1e953 DefaultDispatcher-worker-2 @test#3
  ```

  1处launch的上下文，是scope定义的上下文，即launch的调度器是IO，协程的名字是test

- 理解：对于新创建的协程，它的CoroutineContext会包含一个全新的Job实例

  上述代码1和2处分别创建了两个协程，coroutineContext.get(Job)对象打印出来的结果分别是@5ece6e2d和@5af1e953，也就是说创建新的协程，它的CoroutineContext会包含一个新的Job实例

- 理解：剩下的元素从CoroutineContext的父类继承

  1和2处创建的协程，调度器和协程名都是从scope（CoroutineScope）继承

#### 协程上下文继承公式

> 协程的上下文 = 默认值 + 继承的CoroutineContext + 参数
>
> - 一些元素包含默认值：Dispatcher.Default是默认的CoroutineDispatcher，以及"coroutine"作为默认的CoroutnieName
> - 继承的CoroutineContext是CoroutineScope或者其父协程的CoroutineContext
> - 传入协程构建器的参数的优先级高于继承上下文参数，因此会覆盖对应的参数值

### 异常的传播

> 协程构建器有两种形式：自动传播异常（launch与actor），向用户暴露异常（async与produce）当这些构建器用于创建一个**根协程**时（该协程不是另一个协程的子协程），前者这类构建器，异常会在它发生的第一时间被抛出，而后者则依赖用户来最终消费异常，例如通过await与receive

- testException1

  ````kotlin
      @Test
      fun testException() = runBlocking<Unit> {
          val job = GlobalScope.launch {
              try {
                  throw IndexOutOfBoundsException()
              } catch (e: Exception) {
                  println("Caught IndexOutOfBoundsException $e")
              }
          }
          job.join()
          val deferred = GlobalScope.async {
              throw ArithmeticException()
          }
  
          try {
              deferred.await()
          } catch (e: Exception) {
              println("Caught ArithmeticException $e")
          }
      }
      
  Caught IndexOutOfBoundsException java.lang.IndexOutOfBoundsException
  Caught ArithmeticException java.lang.ArithmeticException
  ````

- testException2

  ````kotlin
      @Test
      fun testException() = runBlocking<Unit> {
          val job = GlobalScope.launch {
              try {
                  throw IndexOutOfBoundsException()
              } catch (e: Exception) {
                  println("Caught IndexOutOfBoundsException $e")
              }
          }
          job.join()
          val deferred = GlobalScope.async {
              println("async")
              throw ArithmeticException()
          }
  
          delay(1000)
      }
      
  Caught IndexOutOfBoundsException java.lang.IndexOutOfBoundsException
  async
  ````

  launch在抛出异常的位置捕获

  async没有调用await没有抛出异常，调用后则能够捕获，即被用户消费

### 异常的传播特性

> 当一个协程由于一个异常而运行失败时，它会传播这个异常并传递给它的父级，接下来，父级会进行下面几步操作：
>
> 1. 取消它自己的子级
> 2. 取消自己
> 3. 将异常传递给父级

#### SupervisorJob

> SupervisorJob启动的协程，抛出异常时，不会影响兄弟协程运行

- supervisorJob

  ```kotlin
  @Test
      fun testSupervisorJob() = runBlocking<Unit> {
          val supervisor = CoroutineScope(SupervisorJob())
          val job1 = supervisor.launch {
              delay(1000)
              println("child 1")
              throw IllegalArgumentException()
          }
          val job2 = supervisor.launch {
              try {
                  delay(Long.MAX_VALUE)
              } finally {
                  println("child 2 finish.")
              }
          }
          joinAll(job1, job2)
      }
  ```

  运行结果：job2抛出异常，但程序没有退出。进入无线delay()，如果SupervisorJob()换成Job()，则job2抛出异常后，job1也被取消，程序退出

  child 1
  Exception in thread "DefaultDispatcher-worker-2 @coroutine#2" java.lang.RuntimeException: Exception while trying to handle coroutine exception
  	at kotlinx.coroutines.CoroutineExceptionHandlerKt.handlerException(CoroutineExceptionHandler.kt:38)
  	at kotlinx.coroutines.CoroutineExceptionHandlerImplKt.handleCoroutineExceptionImpl(CoroutineExceptionHandlerImpl.kt:34)
  	at kotlinx.coroutines.CoroutineExceptionHandlerKt.handleCoroutineException(CoroutineExceptionHandler.kt:33)
  	at kotlinx.coroutines.StandaloneCoroutine.handleJobException(Builders.common.kt:184)
  	at kotlinx.coroutines.JobSupport.tryFinalizeFinishingState(JobSupport.kt:226)
  	at kotlinx.coroutines.JobSupport.tryMakeCompletingSlowPath(JobSupport.kt:849)
  	at kotlinx.coroutines.JobSupport.tryMakeCompleting(JobSupport.kt:811)
  	at kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core(JobSupport.kt:787)
  	at kotlinx.coroutines.AbstractCoroutine.resumeWith(AbstractCoroutine.kt:111)
  	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:46)
  	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)
  	Suppressed: java.lang.IllegalArgumentException
  		at com.henyiwu.okhttpdemo.CoroutineScope2$testSupervisorJob$1$job1$1.invokeSuspend(CoroutineScope.kt:240)
  		at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
  		... 4 more
  Caused by: java.lang.NoClassDefFoundError: android/os/Build$VERSION
  	at kotlinx.coroutines.android.AndroidExceptionPreHandler.handleException(AndroidExceptionPreHandler.kt:39)
  	at kotlinx.coroutines.CoroutineExceptionHandlerImplKt.handleCoroutineExceptionImpl(CoroutineExceptionHandlerImpl.kt:30)
  	... 12 more
  Caused by: java.lang.ClassNotFoundException: android.os.Build$VERSION
  	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:582)
  	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:190)
  	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:499)
  	... 14 more
  Exception in thread "DefaultDispatcher-worker-2 @coroutine#2" java.lang.IllegalArgumentException
  	at com.henyiwu.okhttpdemo.CoroutineScope2$testSupervisorJob$1$job1$1.invokeSuspend(CoroutineScope.kt:240)
  	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
  	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)

- supervisorScope

  ```kotlin
  @Test
      fun testSupervisorScope() = runBlocking<Unit> {
          supervisorScope {
              launch {
                  delay(1000)
                  println("child 1")
                  throw IllegalArgumentException()
              }
              try {
                  delay(Long.MAX_VALUE)
              } finally {
                  println("child 2 finished")
              }
          }
      }
  ```

  val supervisor = CoroutineScope(SupervisorJob())可以替换成supervisorScope()协程作用域构建器，效果一样

  但是，如果在supervisorScope()作用域内报错，子协程全部停止执行

  ```kotlin
  @Test
      fun testSupervisorScope() = runBlocking<Unit> {
          supervisorScope {
              launch {
                  delay(1000)
                  println("child 1")
                  throw IllegalArgumentException()
              }
       		// supervisorScope中抛异常，子协程全部停止
              throw IllformedLocaleException()
              try {
                  delay(Long.MAX_VALUE)
              } finally {
                  println("child 2 finished")
              }
          }
      }
  =======
  ```
[toc]

## 协程

> 协程让异步同步化，消除回调地狱
>
> 协程最核心的点是，函数或者一段程序能够挂起，稍后再从挂起的位置恢复

### 协程的挂起和恢复

> 常规协程的基础操作包括：invoke（或call）和return，协程新增了suspend和resume：
>
> suspend：也成为挂起或暂停，用于暂停执行当前线程，并保存所有局部变量
>
> resume：用于让已暂停的协程从其暂停处继续执行

- 原生创建协程的方法

  ```kotlin
  val continuation = suspend {
              5
          }.createCoroutine(object : Continuation<Int> {
              override val context: CoroutineContext
                  get() = EmptyCoroutineContext
  
              override fun resumeWith(result: Result<Int>) {
                  Log.d("west" ,"Continuation $result")
              }
          })
          continuation.resume(Unit)
  ```

### 堆栈中的函数调用流程

- getUser()

  ````kotlin
  private suspend fun getUser() {
      val user = get()
      show(user)
  }
  
  private suspend fun get() = withContext(Dispatchers.IO) {
      userServiceApi.getUser("Xxx")
  }
  ````

  1. 执行getUser()，栈帧会出现在主线程的栈中
  2. 执行get()，getUser()被挂起
  3. 执行withContext()，get()被挂起
  4. Dispatcher.IO执行完成后，返回值给get()，get()被恢复
  5. get()返回值给getUser()，getUser()被恢复
  
- 问：协程挂起点保存在哪里？

### 协程的调度器

> 所有的协程都必须在调度器中运行，即使它们在主线程上也一样

Dispatcher.Main

> android上的主线程，用来处理一些UI交互和轻量级任务。
>
> - 调用suspend函数
> - 调用ui函数
> - 更新liveData

Dispatcher.IO

> 非主线程
>
> 专为磁盘和网络进行了优化
>
> - 读写数据库
> - 文件读写
> - 网络请求

Dispatcher.Default

> 非主线程
>
> 专为CPU密集型任务进行了优化
>
> - 数组排序
> - JSON数据解析
> - 处理差异判断

任务泄露

> 当某个协程任务丢失，无法跟踪，会导致内存、CPU、磁盘等资源浪费，甚至发送一个无用的网络请求，这种情况称为**任务泄露**
>
> 为了能够避免协程泄露，Kotlin引入了**结构化并发机制**

### 结构化并发

> 使用结构化并发可以做到：
>
> 1. 取消任务，当某个任务不再需要时，取消它
> 2. 跟踪任务，当任务正在执行时，跟踪它
> 3. 发出错误信号，当协程失败时，发出错误信号表明有错误发生

- testSync()

  ```kotlin
  @Test
      fun testSync() = runBlocking {
          val millsTime = measureTimeMillis {
              val one = doOne()
              val two = doTwo()
              println("the result : ${one + two}")
          }
          println("time $millsTime")
      }
  
      private suspend fun doOne() : Int {
          delay(1000)
          return 1
      }
  
      private suspend fun doTwo() : Int {
          delay(1000)
          return 2
      }
  
  执行结果：
  the result : 3
  time 2024
  ```

- testAsync()

  ```kotlin
  @Test
      fun testAsync() = runBlocking {
          val millsTime = measureTimeMillis {
              val one = async { doOne() }
              val two = async { doTwo() }
              println("the result : ${one.await() + two.await()}")
          }
          println("time $millsTime")
      }
  
      private suspend fun doOne() : Int {
          delay(1000)
          return 1
      }
  
      private suspend fun doTwo() : Int {
          delay(1000)
          return 2
      }
  
  执行结果：
  the result : 3
  time 1020
  ```

  使用async，doOne和doTwo同时执行完才打印

- 错误示例

  ```kotlin
  val one = async { doOne() }.await()
  val two = async { doTwo() }.await()
  
  time 2045
  没有并发效果
  ```

### CoroutineScope

> 定义协程必须指定其CoroutineScope，它会跟踪所有协程，同样它还可以取消由它启动的所有协程
>
> 常用的相关API有：
> GlobalScope，生命周期是process级的，即使Activity或Fragment已经被销毁，协程仍然可以执行
>
> MainScope，在Activity中使用，可以在onDestroy()中取消协程
>
> viewModelScope，只能在viewModel中使用，绑定ViewModel生命周期
>
> lifeCycleScope，只能在Activity、Fragment里使用，会绑定Activity和Fragment的生命周期

#### MainScope

- mainScope

  ```kotlin
  // MainScope() 其实是个函数，但是特意设计为大写开头，由工厂创建对象
  val mainScope = MainScope()
  
  // 只要mainScope取消，内部启动的所有协程都会取消
  mainScope.launch {
              val user = getUser()
              log(user.name)
          }
  
  override fun onDestroy() {
          super.onDestroy()
      	// 取消
          mainScope.cancel()
      }
  ```

  如果mainScope还没执行完，调用cancel()会抛出异常

  ```
  kotlinx.coroutines.JobCancellationException: Job was cancelled; job=SupervisorJobImpl{Cancelling}@131d0d4
  ```

- 委托写法

  ```kotlin
  class MainActivity : AppCompatActivity(), CoroutineScope by MainScope(){
  
       override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          setContentView(R.layout.activity_main)
  
           // 直接launch
          launch {
              delay(100000)
          }
      }
  
      override fun onDestroy() {
          super.onDestroy()
          // 直接cancel
          cancel()
      }
  }
  ```

### launch和async返回值比较

> launch：返回一个Job且不带任何结果值
>
> async：返回一个Deferred，Deferred也是一个Job，可以使用await()在一个延期的值上得到结果

- testCoroutineBuilder

  ````kotlin
  @Test
  fun testCoroutineBuilder() {
  	runBlocking {
  		val time = measureTimeMillis {
  			val job1 = launch {
  				delay(2000)
  				IKLog.d("west","job1 finish")
  			}
  
  			val job2 = async {
  				delay(2000)
  				IKLog.d("west", "job2 finish")
  			}
  
  			IKLog.d("west", "job2 result ${job2.await()}")
  		}
  		IKLog.d("west", "time $time")
   	}
  }
  
  ````

job1 finish
  job2 finish
  job2 result kotlin.Unit
  time 2004
  ````
  
  runBlocking会阻塞线程，等待子协程执行完成，主线程才能退出

### join和await协程等待作业

- testCoroutineJoin

  ```kotlin
  runBlocking {
     val time = measureTimeMillis {
         val job1 = launch {
             delay(2000)
             IKLog.d("west","job1 finish")
         }
  
         job1.join()
  
         val job2 = async {
             delay(2000)
             IKLog.d("west", "job2 finish")
         }
  
         IKLog.d("west", "job2 result ${job2.await()}")
     }
     IKLog.d("west", "time $time")
  }
  
  job1 finish
  job2 finish
  job2 result kotlin.Unit
  time 4003
```

  join()使job1与job2串行执行

- testCoroutineAwait

  ```kotlin
  runBlocking {
      val time = measureTimeMillis {
          val job1 = async {
              delay(2000)
              IKLog.d("west","job1 finish")
          }
  
          job1.await()
  
          launch {
              delay(2000)
              IKLog.d("west", "job2 finish")
          }
  
      }
      IKLog.d("west", "time $time")
  }
  
  2022-09-04 16:24:22.043 25095-25095/com.gzik.pandora D/west: [, , 0]:job1 finish
  2022-09-04 16:24:22.044 25095-25095/com.gzik.pandora D/west: [, , 0]:time 2002
  2022-09-04 16:24:24.046 25095-25095/com.gzik.pandora D/west: [, , 0]:job2 finish
  注意这里用时2s，且time先打印，job2finish后打印
  ```
  
  ```java
  改为
  runBlocking {
      val time = measureTimeMillis {
          val job1 = async {
              delay(2000)
              IKLog.d("west","job1 finish")
          }
  
          job1.await()
  
          val job2 = launch {
              delay(2000)
              IKLog.d("west", "job2 finish")
          }
          job2.join()
      }
      IKLog.d("west", "time $time")
  }
  
  2022-09-04 16:27:38.758 26317-26317/com.gzik.pandora D/west: [, , 0]:job1 finish
  2022-09-04 16:27:40.761 26317-26317/com.gzik.pandora D/west: [, , 0]:job2 finish
  2022-09-04 16:27:40.761 26317-26317/com.gzik.pandora D/west: [, , 0]:time 4004
  ```
  
  假如不调用job1.await()
  
- testCoroutineAwait

  ```kotlin
          runBlocking {
              val start = System.currentTimeMillis()
              val job1 = async {
                  delay(2000)
                  Log.d("west", "time2 ：${System.currentTimeMillis()-start}")
              }
              // 同上，调用job1.await()，job1执行完成，得到发挥结果后，才执行job2，job3
              val job2 = async {
                  delay(2000)
                  Log.d("west", "time3 ：${System.currentTimeMillis()-start}")
              }
              val job3 = async {
                  delay(2000)
                  Log.d("west", "time4 ：${System.currentTimeMillis()-start}")
              }
              val end = System.currentTimeMillis()
              Log.d("west", "time1 ：${end-start}")
          }
  ```

  结果：

  D/west: time1 ：4
  D/west: time2 ：2009
  D/west: time3 ：2010
  D/west: time4 ：2010

### 协程的启动模式

#### DEFAULT

> 协程创建后，立即开始调度（不代表立即执行），在调度前如果协程被取消，其将直接进入取消响应的状态

- default

  ```kotlin
  runBlocking {
      val time = measureTimeMillis {
          val job = launch(start = CoroutineStart.DEFAULT) {
              delay(10000)
              IKLog.d("west", "println 1")
          }
          delay(1000)
          job.cancel()
      }
      IKLog.d("west", "time $time")
  }

  D/west: time 1020
  ```
  
  启动模式为CoroutineStart.DEFAULT，cancel()时会立刻取消协程

#### ATOMIC

> 协程创建后，立刻开始调度，协程执行第一个挂起点之前不响应取消

- atomic

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = launch(start = CoroutineStart.ATOMIC) {
              /**
               * 重要代码
               */
              delay(10000)
              Log.d("west", "job cancel")
          }
          delay(1000)
          job.cancel()
      }
  ```

  delay()为第一个挂起点，如果启动模式为CoroutineStart.ATOMIC，协程执行到delay()之前调用job.cancel()，不响应取消状态。

  这样做的意义：重要代码必须执行，不能被cancel打断

#### LAZY

> 只有协程被需要时，包括主动调用协程的start、join或者await等函数时才会开始调度，如果调度前就被取消，那么该协程将直接进入异常结束状态

- lazy

  ```kotlin
  runBlocking {
      val job = launch(start = CoroutineStart.LAZY) {
          IKLog.d("west", "start")
      }
      // job.start()
      IKLog.d("west", "finish")
  }
  
  ```

2022-09-04 16:44:05.776 29010-29010/com.gzik.pandora D/west: [, , 0]:finish

__________________________________________________

  runBlocking {
    val job = launch(start = CoroutineStart.LAZY) {
  		IKLog.d("west", "start")
  	}
  	job.start()
  	IKLog.d("west", "finish")
  }
  2022-09-04 16:53:00.205 29587-29587/com.gzik.pandora D/west: [, , 0]:finish
  2022-09-04 16:53:00.206 29587-29587/com.gzik.pandora D/west: [, , 0]:start

__________________________________________________

  runBlocking {
      val job = launch(start = CoroutineStart.DEFAULT) {
          IKLog.d("west", "start")
      }
      IKLog.d("west", "finish")
  }

  2022-09-04 16:55:34.557 31027-31027/com.gzik.pandora D/west: [, , 0]:finish
  2022-09-04 16:55:34.557 31027-31027/com.gzik.pandora D/west: [, , 0]:start
  ```
  

#### UNDISPATCHERD

>  协程创建后立即进入当前函数调用栈中执行，直到遇到第一个正真挂起的点

- undispatched

  ```kotlin
  fun testCoroutineAwait() = runBlocking {
          val job = async(context = Dispatchers.IO, start = CoroutineStart.UNDISPATCHED) {
              Log.d("west", "thread ${Thread.currentThread().name}")
          }
      }
  ```

  当前函数调用栈是主线程，Log.d("west", "thread ${Thread.currentThread().name}")也会在主线程执行，直到遇到第一个挂起点才转为IO线程

### 协程的作用域构建器

> - coroutineScope和runBlocking
>
> 1. runBlocking是常规函数（不是suspend），coroutineScope是挂起函数
> 2. 它们都会等待其协程体以及所有子协程结束，主要区别在于runBlocking方法会阻塞当前线程来等待，而coroutineScope只是挂起，会释放底层线程用于其他用途。

> - coroutineScope和supervisorScope
>
> 1. coroutineScope：一个协程失败了，所有兄弟协程也会取消
> 2. supervisorScope：一个协程失败了，不会影响其他兄弟协程
>
> ```kotlin
> runBlocking {
>     supervisorScope {
>         val job1 = launch {
>             delay(1000)
>             IKLog.d("west", "job1 finish")
>             throw IllegalArgumentException()
>         }
>         val job2 = launch {
>             delay(2000)
>             IKLog.d("west", "job2 finish")
>         }
>     }
> }
> 
> 2022-09-04 17:14:10.169 7570-7570/com.gzik.pandora D/west: [, , 0]:job1 finish
> 2022-09-04 17:14:11.170 7570-7570/com.gzik.pandora D/west: [, , 0]:job2 finish
> 程序异常退出
> _________________________________________________________
> 
> try {
>     runBlocking {
>         supervisorScope {
>             val job1 = launch {
>                 delay(1000)
>                 IKLog.d("west", "job1 finish")
>                 throw IllegalArgumentException()
>             }
>             val job2 = launch {
>                 delay(2000)
>                 IKLog.d("west", "job2 finish")
>             }
>         }
>     }
> } catch (e: Exception) {
>     IKLog.d("west", "e $e")
> }
> 
> 2022-09-04 17:05:15.340 4301-4301/com.gzik.pandora D/west: [, , 0]:job1 finish
> 2022-09-04 17:05:16.339 4301-4301/com.gzik.pandora D/west: [, , 0]:job2 finish
> 程序异常退出
> ```
>
> ```kotlin
> runBlocking {
>     coroutineScope {
>         val job1 = launch {
>             delay(1000)
>             IKLog.d("west", "job1 finish")
>             throw IllegalArgumentException()
>         }
>         val job2 = launch {
>             delay(2000)
>             IKLog.d("west", "job2 finish")
>         }
>     }
> }
> 2022-09-04 17:12:39.892 6411-6411/com.gzik.pandora D/west: [, , 0]:job1 finish
> 程序异常退出
> ________________________________________________________________________
> 
> try {
>     runBlocking {
>         coroutineScope {
>             val job1 = launch {
>                 delay(1000)
>                 IKLog.d("west", "job1 finish")
>                 throw IllegalArgumentException()
>             }
>             val job2 = launch {
>                 delay(2000)
>                 IKLog.d("west", "job2 finish")
>             }
>         }
>     }
> } catch (e: Exception) {
>     IKLog.d("west", "e $e")
> }
> 
> 2022-09-04 17:07:07.440 5356-5356/com.gzik.pandora D/west: [, , 0]:job1 finish
> 2022-09-04 17:07:07.442 5356-5356/com.gzik.pandora D/west: [, , 0]:e java.lang.IllegalArgumentException
> 异常被cache，程序没退出
> ```

### Job

> - 对于每一个创建的协程，通过launch或者async，都会返回一个实例，这个实例是协程的唯一标识，并且负责管理协程的生命周期。
>
> - 一个任务可以包含一些列的状态：新创建（New）、活跃（Active）、完成中（Completing）、已完成（Completed）、取消中（Cancelling）和已取消（Cancelled）。虽然我们无法直接访问这些状态，但是我们可以访问Job的属性：isAlive、isCancelled和isCompleted
>
>   ```
>   job.isActive
>   job.isCompleted
>   job.isCancelled
>   ```

#### Job的生命周期

> 如果协程处于活跃状态，协程运行出错或者调用job.cancel()都会将当前任务置为取消中，当所有子协程都完成后，协程会进入已取消的状态，此时isCompleted = true

### 协程的取消

> - 取消作用域会取消它的子协程
> - 被取消的子协程不会影响其他兄弟协程
> - 协程通过抛出一个特殊异常CancellationException来处理取消操作
> - 所有kotlin.coroutines中的挂起函数（withContext、delay等）都是可以取消的

- test

  ```kotlin
  fun testScopeCancel() = runBlocking {
          val scope = CoroutineScope(Dispatchers.Default)
          scope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
          scope.launch {
              delay(1000)
              Log.d("west", "job2")
          }
          delay(100)
          scope.cancel()
          delay(1000)
      }
  
  // 无输出结果
  ```

#### 被取消的子协程不会影响其余兄弟协程

- test

  ```kotlin
      fun testBrotherCancel() = runBlocking {
          val scope = CoroutineScope(Dispatchers.Default)
          val job1 = scope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
          val job2 = scope.launch {
              delay(1000)
              Log.d("west", "job2")
          }
          delay(100)
          job1.cancel()
          delay(1000)
      }
  
  // 2021-12-11 10:42:57.747 23248-23312/com.henyiwu.myapplication D/west: job2
  ```

- test

  ```kotlin
      @Test
      fun testCancellationCancel() = runBlocking {
          val job1 = GlobalScope.launch {
              delay(1000)
              Log.d("west", "job1")
          }
      }
  
  // 无打印结果，runBlocking不会等待GlobalScope执行完成，GlobalScope有自己的上下文
  ```

#### 协程的取消异常

- testCancellationCancel

  ```kotlin
      fun testCancellationCancel() = runBlocking {
          val job1 = GlobalScope.launch {
              try {
                  delay(1000)
                  Log.d("west", "job1")
              } catch (e: Exception) {
                  Log.d("west", "e: $e")
              }
          }
          delay(100)
          job1.cancel(CancellationException(("异常了")))
          job1.join()
      }
      
      // Failure(java.util.concurrent.CancellationException: 异常了)
  ```

#### CPU密集型任务取消

> - isActive是一个可以被使用的CoroutineScope中的扩展属性，检查Job是否处于活跃状态
> - ensureActive()，如果job处于非活跃状态，这个方法会抛出异常
> - yield函数会检查所在协程的状态，如果已经取消，则抛出CancellationException予以响应。此外，它还会尝试让出线程的执行权，给其他协程提供机会。

- test

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5) {
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
      
  Job: Im sleeping 0
  Job: Im sleeping 1
  Job: Im sleeping 2
  Job: Im sleeping 3
  im tried of waiting
  Job: Im sleeping 4
  main: Now i can quit
  ```

  CPU密集型的，无法直接cancel()，可以改为

- isActive

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5 && isActive) {
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
      
  Job: Im sleeping 0
  Job: Im sleeping 1
  Job: Im sleeping 2
  Job: Im sleeping 3
  im tried of waiting
  main: Now i can quit
  ```

  因为调用cancel()时，job的isActive状态会转为false

- 或者使用ensureActive()

  ```kotlin
      @Test
      fun testCancelCpuTaskByIsActive() = runBlocking<Unit> {
          val startTime = System.currentTimeMillis()
          val job = launch(Dispatchers.Default) {
              var nextPrintTime = startTime
              var i = 0
              while (i < 5) {
                  ensureActive()
                  if (System.currentTimeMillis() >= nextPrintTime) {
                      println("Job: Im sleeping ${i++}")
                      nextPrintTime += 500
                  }
              }
          }
          delay(1500)
          println("im tried of waiting")
          job.cancelAndJoin()
          println("main: Now i can quit")
      }
  ```

#### 协程取消的副作用

> 协程取消后，后续代码不会执行，如果后续代码是释放资源，可能造成内存泄漏

- 处理

  ```kotlin
      @Test
      fun testSet() = runBlocking {
          val job = launch {
              try {
                  repeat(1000) {
                      println("repeat $it")
                      delay(1000)
                  }
              } catch (e: Exception) {
                  println("exception : $e")
              }
          }
          delay(1400)
          println("退出")
          job.cancelAndJoin()
      }
  
  repeat 0
  repeat 1
  退出
  exception : kotlinx.coroutines.JobCancellationException: Job was cancelled; job="coroutine#2":StandaloneCoroutine{Cancelling}@61230f6a
  ```

  应该在finally中处理释放资源

#### 不能取消的任务

> - 处于取消状态中的协程不能够挂起（运行不能取消的代码），当协程被取消后需要调用挂起函数，我们需要将清理任务放至在NonCancellable ContinueContext中。
> - 这样会挂起运行中的代码，并保持协程的取消状态直到任务完成为止

- 可取消的协程

  ```kotlin
      @Test
      fun testNoCancellable() = runBlocking {
          val job = launch {
              try {
                  repeat(1000) { i->
                      println("job: i m sleeping $i...")
                      delay(500)
                  }
              } finally {
                  println("job i m running finally")
                  delay(1000L)
                  println("i m non-cancellable")
              }
          }
          delay(1300)
          println("i m tried of waiting")
          job.cancelAndJoin()
          println("now i m quit")
      }
  
  job: i m sleeping 0...
  job: i m sleeping 1...
  job: i m sleeping 2...
  i m tried of waiting
  job i m running finally
  now i m quit
  ```

  finally中**println("i m non-cancellable")**不会打印，job.cancel()后所有协程执行完毕，进程结束

- 不可取消的协程

  ```kotlin
      @Test
      fun testNoCancellable() = runBlocking {
          val job = launch {
              try {
                  repeat(1000) { i->
                      println("job: i m sleeping $i...")
                      delay(500)
                  }
              } finally {
                  withContext(NonCancellable) {
                      println("job i m running finally")
                      delay(5000L)
                      println("i m non-cancellable")
                  }
              }
          }
          delay(1300)
          println("i m tried of waiting")
          job.cancelAndJoin()
          println("now i m quit")
      }
  
  job: i m sleeping 0...
  job: i m sleeping 1...
  job: i m sleeping 2...
  i m tried of waiting
  job i m running finally
  i m non-cancellable
  now i m quit
  ```

  调用job.cancel()后，进入finally代码块，挂起五秒后执行println("i m non-cancellable")

####  超时任务

> - 很多情况下取消一个协程的理由是它有可能超时
> - withTimeoutOrNull通过返回null来进行超时操作，从而代替抛出一个异常

- witchTimeout

  ```kotlin
      @Test
      fun testTimeout() = runBlocking {
          val value = withTimeout(1300) {
              repeat(1000) {
                  println("job im sleeping $it")
                  delay(1000)
              }
              "Done"
          }
          println("result is $value")
      }
  
  
  job im sleeping 0
  job im sleeping 1
  
  kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
  
  	at kotlinx.coroutines.TimeoutKt.TimeoutCancellationException(Timeout.kt:126)
  	at kotlinx.coroutines.TimeoutCoroutine.run(Timeout.kt:92)
  	at kotlinx.coroutines.EventLoopImplBase$DelayedRunnableTask.run(EventLoop.common.kt:491)
  	at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:270)
  	at kotlinx.coroutines.DefaultExecutor.run(DefaultExecutor.kt:68)
  	at java.base/java.lang.Thread.run(Thread.java:844)
  ```

  超时的时候withTimeout会抛异常

- withTimeoutOrNull

  ```kotlin
      @Test
      fun testTimeout() = runBlocking {
          val value = withTimeoutOrNull(1300) {
              repeat(1000) {
                  println("job im sleeping $it")
                  delay(1000)
              }
              "Done"
          }
          println("result is $value")
      }
  
  job im sleeping 0
  job im sleeping 1
  result is null
  
  Process finished with exit code 0
  ```

  超时时返回null

### 协程的上下文

> CoroutineContext是一组用于定义协程行为的元素，它由以下几项构成
>
> 1. job：控制协程的生命周期
> 2. CoroutineDispatcher：向合适的线程分发任务
> 3. CoroutineName：协程的名称，调试的时候有用
> 4. CoroutineExceptionHandler：处理未捕捉的异常

- testCoroutineContext

  ```kotlin
      @Test
      fun testCoroutineContext() = runBlocking<Unit> {
          // CoroutineContext对+进行重载
          launch(Dispatchers.Default + CoroutineName("test")) {
              println("i m working in thread $this")
          }
      }
  ```

### 协程上下文继承

> 对于新创建的协程，它的CoroutineContext会包含一个全新的Job实例，它会帮助我们控制协程的生命周期，而剩下的元素从CoroutineContext的父类继承，该父类可能是另外一个协程或者创建该协程的CoroutineScope

- testCoroutineContextThread

  ```kotlin
      @Test
      fun testCoroutineContextThread() = runBlocking {
          val scope = CoroutineScope(Job() + Dispatchers.IO + CoroutineName("test"))
          val job = scope.launch { // 1
              println("${coroutineContext.get(Job)} ${Thread.currentThread().name}")
              val result = async { // 2
                  println("${coroutineContext[Job]} ${Thread.currentThread().name}")
                  "OK"
              }.await()
          }
          job.join()
      }
  
  "test#2":StandaloneCoroutine{Active}@5ece6e2d DefaultDispatcher-worker-2 @test#2
  "test#3":DeferredCoroutine{Active}@5af1e953 DefaultDispatcher-worker-2 @test#3
  ```

  1处launch的上下文，是scope定义的上下文，即launch的调度器是IO，协程的名字是test

- 理解：对于新创建的协程，它的CoroutineContext会包含一个全新的Job实例

  上述代码1和2处分别创建了两个协程，coroutineContext.get(Job)对象打印出来的结果分别是@5ece6e2d和@5af1e953，也就是说创建新的协程，它的CoroutineContext会包含一个新的Job实例

- 理解：剩下的元素从CoroutineContext的父类继承

  1和2处创建的协程，调度器和协程名都是从scope（CoroutineScope）继承

#### 协程上下文继承公式

> 协程的上下文 = 默认值 + 继承的CoroutineContext + 参数
>
> - 一些元素包含默认值：Dispatcher.Default是默认的CoroutineDispatcher，以及"coroutine"作为默认的CoroutnieName
> - 继承的CoroutineContext是CoroutineScope或者其父协程的CoroutineContext
> - 传入协程构建器的参数的优先级高于继承上下文参数，因此会覆盖对应的参数值

### 异常的传播

> 协程构建器有两种形式：自动传播异常（launch与actor），向用户暴露异常（async与produce）当这些构建器用于创建一个**根协程**时（该协程不是另一个协程的子协程），前者这类构建器，异常会在它发生的第一时间被抛出，而后者则依赖用户来最终消费异常，例如通过await与receive

- testException1

  ````kotlin
      @Test
      fun testException() = runBlocking<Unit> {
          val job = GlobalScope.launch {
              try {
                  throw IndexOutOfBoundsException()
              } catch (e: Exception) {
                  println("Caught IndexOutOfBoundsException $e")
              }
          }
          job.join()
          val deferred = GlobalScope.async {
              throw ArithmeticException()
          }
  
          try {
              deferred.await()
          } catch (e: Exception) {
              println("Caught ArithmeticException $e")
          }
      }
      
  Caught IndexOutOfBoundsException java.lang.IndexOutOfBoundsException
  Caught ArithmeticException java.lang.ArithmeticException
  ````

- testException2

  ````kotlin
      @Test
      fun testException() = runBlocking<Unit> {
          val job = GlobalScope.launch {
              try {
                  throw IndexOutOfBoundsException()
              } catch (e: Exception) {
                  println("Caught IndexOutOfBoundsException $e")
              }
          }
          job.join()
          val deferred = GlobalScope.async {
              println("async")
              throw ArithmeticException()
          }
  
          delay(1000)
      }
      
  Caught IndexOutOfBoundsException java.lang.IndexOutOfBoundsException
  async
  ````

  launch在抛出异常的位置捕获

  async没有调用await没有抛出异常，调用后则能够捕获，即被用户消费

### 异常的传播特性

> 当一个协程由于一个异常而运行失败时，它会传播这个异常并传递给它的父级，接下来，父级会进行下面几步操作：
>
> 1. 取消它自己的子级
> 2. 取消自己
> 3. 将异常传递给父级

#### SupervisorJob

> SupervisorJob启动的协程，抛出异常时，不会影响兄弟协程运行

- supervisorJob

  ```kotlin
  @Test
      fun testSupervisorJob() = runBlocking<Unit> {
          val supervisor = CoroutineScope(SupervisorJob())
          val job1 = supervisor.launch {
              delay(1000)
              println("child 1")
              throw IllegalArgumentException()
          }
          val job2 = supervisor.launch {
              try {
                  delay(Long.MAX_VALUE)
              } finally {
                  println("child 2 finish.")
              }
          }
          joinAll(job1, job2)
      }
  ```

  运行结果：job2抛出异常，但程序没有退出。进入无线delay()，如果SupervisorJob()换成Job()，则job2抛出异常后，job1也被取消，程序退出

  child 1
  Exception in thread "DefaultDispatcher-worker-2 @coroutine#2" java.lang.RuntimeException: Exception while trying to handle coroutine exception
  	at kotlinx.coroutines.CoroutineExceptionHandlerKt.handlerException(CoroutineExceptionHandler.kt:38)
  	at kotlinx.coroutines.CoroutineExceptionHandlerImplKt.handleCoroutineExceptionImpl(CoroutineExceptionHandlerImpl.kt:34)
  	at kotlinx.coroutines.CoroutineExceptionHandlerKt.handleCoroutineException(CoroutineExceptionHandler.kt:33)
  	at kotlinx.coroutines.StandaloneCoroutine.handleJobException(Builders.common.kt:184)
  	at kotlinx.coroutines.JobSupport.tryFinalizeFinishingState(JobSupport.kt:226)
  	at kotlinx.coroutines.JobSupport.tryMakeCompletingSlowPath(JobSupport.kt:849)
  	at kotlinx.coroutines.JobSupport.tryMakeCompleting(JobSupport.kt:811)
  	at kotlinx.coroutines.JobSupport.makeCompletingOnce$kotlinx_coroutines_core(JobSupport.kt:787)
  	at kotlinx.coroutines.AbstractCoroutine.resumeWith(AbstractCoroutine.kt:111)
  	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:46)
  	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)
  	Suppressed: java.lang.IllegalArgumentException
  		at com.henyiwu.okhttpdemo.CoroutineScope2$testSupervisorJob$1$job1$1.invokeSuspend(CoroutineScope.kt:240)
  		at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
  		... 4 more
  Caused by: java.lang.NoClassDefFoundError: android/os/Build$VERSION
  	at kotlinx.coroutines.android.AndroidExceptionPreHandler.handleException(AndroidExceptionPreHandler.kt:39)
  	at kotlinx.coroutines.CoroutineExceptionHandlerImplKt.handleCoroutineExceptionImpl(CoroutineExceptionHandlerImpl.kt:30)
  	... 12 more
  Caused by: java.lang.ClassNotFoundException: android.os.Build$VERSION
  	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:582)
  	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:190)
  	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:499)
  	... 14 more
  Exception in thread "DefaultDispatcher-worker-2 @coroutine#2" java.lang.IllegalArgumentException
  	at com.henyiwu.okhttpdemo.CoroutineScope2$testSupervisorJob$1$job1$1.invokeSuspend(CoroutineScope.kt:240)
  	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
  	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:241)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
  	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:740)

- supervisorScope

  ```kotlin
  @Test
      fun testSupervisorScope() = runBlocking<Unit> {
          supervisorScope {
              launch {
                  delay(1000)
                  println("child 1")
                  throw IllegalArgumentException()
              }
              try {
                  delay(Long.MAX_VALUE)
              } finally {
                  println("child 2 finished")
              }
          }
      }
  ```

  val supervisor = CoroutineScope(SupervisorJob())可以替换成supervisorScope()协程作用域构建器，效果一样

  但是，如果在supervisorScope()作用域内报错，子协程全部停止执行

  ```kotlin
  @Test
      fun testSupervisorScope() = runBlocking<Unit> {
          supervisorScope {
              launch {
                  delay(1000)
                  println("child 1")
                  throw IllegalArgumentException()
              }
       		// supervisorScope中抛异常，子协程全部停止
              throw IllformedLocaleException()
              try {
                  delay(Long.MAX_VALUE)
              } finally {
                  println("child 2 finished")
              }
          }
      }
```

### 全局捕获协程异常

1. 全局异常捕获器可以捕获到所有未捕获的异常，但是不能阻止程序退出，一般用于上报异常
2. 在classpath下创建META-INF/services目录，并创建一个名为kotlin.coroutines.CoroutinesExceptionHandler文件，内容是全局异常不获取的全类名

- main/resources/META-INF/services/kotlinx.coroutines.CoroutineExceptionHandler

  ```
  com.gzik.pandora.GlobalCoroutineExceptionHandler
  ```

- GlobalCoroutineExceptionHandler

  ```java
  class GlobalCoroutineExceptionHandler : CoroutineExceptionHandler{
  
      override val key = CoroutineExceptionHandler
  
      override fun handleException(context: CoroutineContext, exception: Throwable) {
          IKLog.d("west", "un handle exception $exception")
      }
  }
  =======
  ```
>>>>>>> 20fde05751b2a450b108e56f3c42fd453a77796c
>>>>>>> 2fefa5e82c2ba0fbc7015e9c6474730ce4f82594
  
  ```
  
  ```