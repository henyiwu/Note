[toc]

## 协程

> 协程让异步同步化，消除回调地狱
>
> 协程最核心的点是，函数或者一段程序能够挂起，稍后再从挂起的位置恢复

### 协程的挂起和恢复

> 常规协程的基础操作包括：invoke（或call）和return，协程新增了suspend和resume：
>
> suspend：也成为挂起或暂停，用于暂停执行当前线程，并保存所有局部变量
>
> resume：用于让已暂停的协程从其暂停处继续执行

- 原生创建协程的方法

  ```kotlin
  val continuation = suspend {
              5
          }.createCoroutine(object : Continuation<Int> {
              override val context: CoroutineContext
                  get() = EmptyCoroutineContext
  
              override fun resumeWith(result: Result<Int>) {
                  Log.d("west" ,"Continuation $result")
              }
          })
          continuation.resume(Unit)
  ```

### 堆栈中的函数调用流程

- getUser()

  ````kotlin
  private suspend fun getUser() {
      val user = get()
      show(user)
  }
  
  private suspend fun get() = withContext(Dispatchers.IO) {
      userServiceApi.getUser("Xxx")
  }
  ````

  1. 执行getUser()，栈帧会出现在主线程的栈中
  2. 执行get()，getUser()被挂起
  3. 执行withContext()，get()被挂起
  4. Dispatcher.IO执行完成后，返回值给get()，get()被恢复
  5. get()返回值给getUser()，getUser()被恢复
  
- 问：协程挂起点保存在哪里？

### 协程的调度器

> 所有的协程都必须在调度器中运行，即使它们在主线程上也一样

Dispatcher.Main

> android上的主线程，用来处理一些UI交互和轻量级任务。
>
> - 调用suspend函数
> - 调用ui函数
> - 更新liveData

Dispatcher.IO

> 非主线程
>
> 专为磁盘和网络进行了优化
>
> - 读写数据库
> - 文件读写
> - 网络请求

Dispatcher.Default

> 非主线程
>
> 专为CPU密集型任务进行了优化
>
> - 数组排序
> - JSON数据解析
> - 处理差异判断

任务泄露

> 当某个协程任务丢失，无法跟踪，会导致内存、CPU、磁盘等资源浪费，甚至发送一个无用的网络请求，这种情况称为**任务泄露**
>
> 为了能够避免协程泄露，Kotlin引入了**结构化并发机制**

### 结构化并发

> 使用结构化并发可以做到：
>
> 1. 取消任务，当某个任务不再需要时，取消它
> 2. 跟踪任务，当任务正在执行时，跟踪它
> 3. 发出错误信号，当协程失败时，发出错误信号表明有错误发生

- testSync()

  ```kotlin
  @Test
      fun testSync() = runBlocking {
          val millsTime = measureTimeMillis {
              val one = doOne()
              val two = doTwo()
              println("the result : ${one + two}")
          }
          println("time $millsTime")
      }
  
      private suspend fun doOne() : Int {
          delay(1000)
          return 1
      }
  
      private suspend fun doTwo() : Int {
          delay(1000)
          return 2
      }
  
  执行结果：
  the result : 3
  time 2024
  ```

- testAsync()

  ```kotlin
  @Test
      fun testAsync() = runBlocking {
          val millsTime = measureTimeMillis {
              val one = async { doOne() }
              val two = async { doTwo() }
              println("the result : ${one.await() + two.await()}")
          }
          println("time $millsTime")
      }
  
      private suspend fun doOne() : Int {
          delay(1000)
          return 1
      }
  
      private suspend fun doTwo() : Int {
          delay(1000)
          return 2
      }
  
  执行结果：
  the result : 3
  time 1020
  ```

  使用async，doOne和doTwo同时执行完才打印

- 错误示例

  ```kotlin
  val one = async { doOne() }.await()
  val two = async { doTwo() }.await()
  
  time 2045
  没有并发效果
  ```

### CoroutineScope

> 定义协程必须指定其CoroutineScope，它会跟踪所有协程，同样它还可以取消由它启动的所有协程
>
> 常用的相关API有：
> GlobalScope，生命周期是process级的，即使Activity或Fragment已经被销毁，协程仍然可以执行
>
> MainScope，在Activity中使用，可以在onDestroy()中取消协程
>
> viewModelScope，只能在viewModel中使用，绑定ViewModel生命周期
>
> lifeCycleScope，只能在Activity、Fragment里使用，会绑定Activity和Fragment的生命周期

#### MainScope

- mainScope

  ```kotlin
  // MainScope() 其实是个函数，但是特意设计为大写开头，由工厂创建对象
  val mainScope = MainScope()
  
  // 只要mainScope取消，内部启动的所有协程都会取消
  mainScope.launch {
              val user = getUser()
              log(user.name)
          }
  
  override fun onDestroy() {
          super.onDestroy()
      	// 取消
          mainScope.cancel()
      }
  ```

  如果mainScope还没执行完，调用cancel()会抛出异常

  ```
  kotlinx.coroutines.JobCancellationException: Job was cancelled; job=SupervisorJobImpl{Cancelling}@131d0d4
  ```

- 委托写法

  ```kotlin
  class MainActivity : AppCompatActivity(), CoroutineScope by MainScope(){
  
       override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          setContentView(R.layout.activity_main)
  
           // 直接launch
          launch {
              delay(100000)
          }
      }
  
      override fun onDestroy() {
          super.onDestroy()
          // 直接cancel
          cancel()
      }
  }
  ```

### launch和async返回值比较

> launch：返回一个Job且不带任何结果值
>
> async：返回一个Deferred，Deferred也是一个Job，可以使用await()在一个延期的值上得到结果

- testCoroutineBuilder

  ````kotlin
  @Test
      fun testCoroutineBuilder() {
          runBlocking {
  
              // Job
              val job1 = launch {
                  delay(2000)
                  println("job1 finish")
              }
  
              // Deferred(推迟)
              val job2 = async {
                  delay(2000)
                  println("job2 finish")
              }
  
              println("job2 result ${job2.await()}")
          }
      }
  ````

  runBlocking会阻塞线程，等待子协程执行完成，主线程才能退出

### join和await协程等待作业

- testCoroutineJoin

  ```kotlin
   @Test
      fun testCoroutineJoin() {
          runBlocking {
              val job1 = launch {
                  delay(2000)
                  println("one")
              }
              // join():job1执行完成后才启动job2、job3
              // 如果不加入join()，job1,job2,job3可并发执行
              job1.join()
              val job2 = launch {
                  delay(2000)
                  println("two")
              }
              val job3 = launch {
                  delay(2000)
                  println("three")
              }
          }
      }
  ```

- testCoroutineAwait

  ```kotlin
  @Test
      fun testCoroutineAwait() {
          runBlocking {
              val job1 = async {
                  delay(2000)
                  println("one")
              }
              // 同上，调用job1.await()，job1执行完成，得到发挥结果后，才执行job2，job3
              job1.await()
              val job2 = async {
                  delay(2000)
                  println("two")
              }
              val job3 = async {
                  delay(2000)
                  println("three")
              }
          }
      }
  ```

### 协程的启动模式