[toc]

## 代理模式

> 类别：结构型设计模式
>
> 定义：为其他对象提供一种代理以控制这个对象的访问，例如生活中律师为代理人打官司、代购等都属于代理。

###　静态代理

> 以“我”想找代购替我去挪威买一张金属专辑为例。

- IShop（抽象接口，委托人和代理类都需要实现接口）

  ```java
  interface IShop {
      void buy();
  }
  ```

- ME（我，真正想买唱片的人）

  ```java
  class ME implements IShop {
  
      @Override
      public void buy() {
          System.out.println("买张金属专辑");
      }
  }
  ```

- 代理人（替我去买唱片的人）

  ```java
  class Proxy implements IShop {
  
      private IShop mShow;
  
      public Proxy(IShop iShop) {
          this.mShow = iShop;
      }
  
      @Override
      public void buy() {
          System.out.println("去挪威唱片商店");
          mShow.buy();
      }
  }
  ```

- main

  ```java
  public static void main(String[] args) {
      Proxy proxy = new Proxy(new ME());
      proxy.buy();
  }
  ```

  以上是静态代理实现，在代码运行前就已经存在了代理类的class编译文件（我们手动写了Proxy类）。

### 动态代理

> 定义：动态代理对象是在运行时通过反射动态生成代理类的对象，并确定代理谁。
>
> Q：为什么需要动态代理？
> A：如果静态代理模式下，IShop新增一个方法pay()，代理类需要修改，而动态代理类不需要修改，减少维护成本

- 将上述Proxy类改为动态代理类，其他类保持不变

  ```java
  class DynamicShop implements InvocationHandler {
  
      IShop mShow;
  
      public DynamicShop(IShop mShow) {
          this.mShow = mShow;
      }
  
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          if (method.getName().equals("buy")){
              System.out.println("去挪威唱片商店");
          }
          method.invoke(mShow, args);
          return null;
      }
  }
  ```

  借助JDK提供的InvocationHandler接口（该接口只有一个invoke方法），可以将代理实体改为动态代理实体。

- main

  ```java
  public static void main(String[] args) {
      ME wzp = new ME();
      DynamicShop dynamicShop = new DynamicShop(wzp);
      IShop proxy = (IShop) Proxy.newProxyInstance(
              wzp.getClass().getClassLoader(),
              new Class[] {IShop.class},
              dynamicShop
      ); 
      proxy.buy();
  }
  ```

  调用Proxy.newProxyInstance()生成动态代理对象，InvocationHandler的invoke()认为是对所委托事物的一种增强，通常是委托人无法完成的需求。动态代理概念中的动态变现为，在DynamicShop()中可以传入任何实现IShop接口的委托人。

### 动态代理在安卓中的应用

####　Hook Java

> 在SDK开发环境中修改Java代码

- Hook startActivity

  > 目的：使用Hook劫持startActivity()，在这个方法中加入我们自己的逻辑。

- startActivityForResult

  ```java
  @Override
      @UnsupportedAppUsage
      public void startActivityForResult(
              String who, Intent intent, int requestCode, @Nullable Bundle options) {
          Uri referrer = onProvideReferrer();
          if (referrer != null) {
              intent.putExtra(Intent.EXTRA_REFERRER, referrer);
          }
          options = transferSpringboardActivityOptions(options);
          Instrumentation.ActivityResult ar =
              mInstrumentation.execStartActivity(
                  this, mMainThread.getApplicationThread(), mToken, who,
                  intent, requestCode, options);
          if (ar != null) {
              mMainThread.sendActivityResult(
                  mToken, who, requestCode,
                  ar.getResultCode(), ar.getResultData());
          }
          cancelInputsAndStartExitTransition(options);
      }
  ```

  启动activity最终是通过mInstrumentation启动，所以我们选择Instrumentation作为Hook点，用代理Instrumentation代替原始的Instrumentation。

- InstrumentationProxy

  ```java
  public class InstrumentationProxy extends Instrumentation {
  
      private static final String TAG = "InstrumentationProxy";
      Instrumentation instrumentation;
  
      public InstrumentationProxy(Instrumentation instrumentation) {
          this.instrumentation = instrumentation;
      }
  
      public ActivityResult execStartActivity(
              Context who, IBinder contextThread, IBinder token,
              Activity target, Intent intent, int requestCode, Bundle options
      ) {
          // 自定义插入的代码
          Log.d(TAG, "Hook Success");
          // 正常流程的代码
          try {
              Method execStartActivity = Instrumentation.class.getDeclaredMethod(
                      "execStartActivity", Context.class, IBinder.class, IBinder.class,
                      Activity.class, Intent.class, int.class, Bundle.class);
              return (ActivityResult) execStartActivity.invoke(
                      instrumentation, who, contextThread, token, target, intent, requestCode, options);
          } catch (Exception e) {
              throw new RuntimeException(e);
          }
      }
  }
  ```

- MainActivity

  ```java
  class MainActivity : AppCompatActivity() {
  
      override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          setContentView(R.layout.activity_main)
          replaceContextInstrumentation(this)
          val intent = Intent(Intent.ACTION_VIEW)
          intent.data = Uri.parse("http://www.baidu.com")
          startActivity(intent)
      }
  
      private fun replaceContextInstrumentation(activity: Activity?) {
          try {
              // 得到Activity的mInstrumentation字段
              val field = Activity::class.java.getDeclaredField("mInstrumentation")
              // 这个成员变量是私有的，取消java的权限控制检查
              field.isAccessible = true
              // 得到传入的Activity的Instrumentation对象
              val instrumentation = field.get(activity) as Instrumentation
              // 创建InstrumentationProxy并注入instrumentation对象
              val instrumentationProxy = InstrumentationProxy(instrumentation)
              // 用instrumentationProxy替换instrumentation
              // set()参数1：被修改变量的对象，参数2：修改后的变量
              field.set(activity, instrumentationProxy)
          } catch (e: Exception) {
              e.printStackTrace()
          }
      }
  }
  ```

  结果：2021-04-05 00:43:22.969 7200-7200/com.example.myapplication D/InstrumentationProxy: Hook Success

  成功在startActivity之前插入了一段Log

  InstrumentationProxy作为一个代理类，与实现类实现相同的借口，具体实现类由构造方法注入，体现动态代理。