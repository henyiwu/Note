[toc]

## 汇编语言

### linux安装nasm环境

> 1. sudo apt-get install nasm
>
> 2. 创建.asm文件	
>
> 3. 64位
>
>    nasm -f elf64 -g -F stabs helloworld.asm -o helloworld.o // 编译
>
>    ld -o helloworld helloworld.o // 链接
>
>    32位
>
>    nasm -f elf -g -F stabs helloworld.asm -o helloworld.o
>
>    ld -m elf_i386 -o helloworld helloworld.o
>
> 4. 运行./hello

### Inter结构下helloworld

- hello.asm

  ```asm
  ; hello.asm 
  section .data            ; 数据段声明
          msg db "Hello, world!", 0xA     ; 要输出的字符串
          len equ $ - msg                 ; 字串长度
  section .text            ; 代码段声明
  global _start            ; 指定入口函数
  _start:                  ; 在屏幕上显示一个字符串
          mov edx, len     ; 参数三：字符串长度
          mov ecx, msg     ; 参数二：要显示的字符串
          mov ebx, 1       ; 参数一：文件描述符(stdout) 
          mov eax, 4       ; 系统调用号(sys_write) 
          int 0x80         ; 调用内核功能
                           ; 退出程序
          mov ebx, 0       ; 参数一：退出代码
          mov eax, 1       ; 系统调用号(sys_exit) 
          int 0x80         ; 调用内核功能
  ```

  nasm -f elf64 hello.asm // 编译
  ld -s -o hello hello.o // 连接
  ./hello // 执行

  Hello, world!

### 16位结构的cpu

> 概括地讲，一个16位的cpu具有一下几个方面的特征
>
> 1. 运算器（ALU）一次最多可以处理16为的数据
> 2. 寄存器的最大宽度为16位
> 3. 寄存器和运算器之间的通路是16位的

### 8086cpu给出物理地址的方法(物理地址 = 段地址 * 16 + 偏移地址)

> 8086有20位地址总线，可传送20位地址数据，寻址能力为1M，2^20*8bit(8086一个存储单元的容量为8bit) = 1M
>
> 8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力只有64k
>
> 8086cpu采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址（通过地址加法器）
>
> ![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fvanie%2F201103%2F201103030220052921.jpg&refer=http%3A%2F%2Fimages.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1654155294&t=716088c10c40ea642801a286d43dae74)
>
> 地址加法器合成物理地址的方法：物理地址 = 段地址 * 16 + 偏移地址
>
> ![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F2018969-fd967f2e9eec4d5c.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1654155472&t=6030ee30500f5817e8328d1175eba410)
>
> - 物理地址 = 段地址 * 16 + 偏移地址 —— 本质含义
>
>   比喻：比如说学校、体育馆同在一条笔直的单行路上（学校位于路的起点0米处）
>
>   我在学校，要去图书馆，问我那里的地址，我可以用几种方式描述这个地址？
>
>   ————————————————————————————————
>   |																	|											|
>
>   0m（学校）												2000m（体育馆）				2826m(图书馆)
>
>   1) 从学校走2826m到图书馆，这2826m可以认为是图书馆的物理地址
>
>   2) 从学校走2000m到体育馆，从体育馆走826m到图书馆
>
>      第一个距离2000m是相对于起点的基础地址
>
>      第二个距离826m是将对于基础地址的偏移地址

### 寄存器概述

> 8086cpu有14个寄存器，它们的名称为：ax、bx、cx、dx、si、di、sp、bp、ip、cs、ss、ds、es、psw
>
> - 通用寄存器
>
>   8086cpu所有的寄存器都是16位的，可以存放两个字节
>
> 数据18
> 二进制表示10010
> 在寄存器ax中存储：
>
> | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
> | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 1    | 0    |
>
> 一个16位寄存器能存储的最大的数值：2^16-1
>
> 8086上一代的cpu中的寄存器都是8位的，为保证兼容性，这四个寄存器都可以分为两个独立8位的寄存器使用
>
> ax可以分为ah和al
> bx可以分为bh和bl
> cx可以分为ch和cl
> dx可以分为dh和dl

### 几条汇编指令

> | 汇编指令   | 控制cpu完成的操作                  | 用高级语言的语法描述 |
> | ---------- | ---------------------------------- | -------------------- |
> | mov ax, 18 | 将18送入ax                         | ax = 18              |
> | mav ah, 78 | 将78送入ah                         | ah = 78              |
> | add ax, 8  | 将寄存器ax中的数值+8               | ax = ax + 8          |
> | mov ax, bx | 将寄存器bx中的数据送入ax寄存器     | ax = bx              |
> | add ax, bx | 将ax, bx中的内存相加，结果存在ax中 | ax = ax + bx         |
>
> add ax, bx // ax = 8226h, bx = 8226h
> ax = 044ch // 结果应该是1044ch，但一个寄存器只能存16位数据，所以这个1被进位了

### 段的概念

> 若干连续的内存单元可以看作一个段，用段地址 * 16定位段的起始地址，用偏移地址定位段中的内存单元
>
> 1. 段地址 * 16 必然是16的倍数，所以一个段地址的起始地址一定也是16的倍数
> 2. 偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k

### 内存单元地址

> CPU访问内存单元时，必须向内存提供内存单元的物理地址。
>
> 8086cpu内存用段地址和偏移地址移位相加的方法形成了最终的物理地址。
>
> 观察以下地址
>
> | 物理地址 | 段地址 | 偏移地址 |
> | -------- | ------ | -------- |
> | 21F60H   | 2000H  | 1F60H    |
> |          | 2100H  | 0F60H    |
> |          | 21F0H  | 0060H    |
>
> 结论：cpu可以用不同的段地址和偏移地址形成同一个物理地址。
>
> Q：如果给定一个段地址，又通过变化偏移地址进行寻址，最多可以定位多少内存单元?
> A：偏移地址16位，变化范围为0~FFFFH，仅通过偏移地址来寻址最多可以寻64K个内存单元
>
> 在8086pc机中，存储单元的地址用两个元素来描述，即段地址和偏移地址
> “数据在21F60H内存单元中。”对于8086pc机的两种描述
>
> 1. 数据在内存2000:1F60单元中
> 2. 数据在内存2000段的1F60H单元中
>
> 可根据需要，将地址连续，起始地址为16的倍数的一组内存单元定义为一个段

### 段寄存器

> 段寄存器就是提供段地址的
>
> 8086cpu有4个段寄存器：cs（code  segment ）、ds（data segment）、ss（stack segment）、es（extra segment）
>
> 当8086cpu要访问内存时，由这4个段寄存器提供内存单元的段地址

- CS和IP

> CS和IP是8086CPU中最关键的寄存器，它们指示了cpu当前要读取指令的地址
>
> CS：代码段寄存器
> IP：指令指针寄存器
>
> - 8086pc工作过程的简要描述
>
>   1. 从cs:ip指向内存单元读取指令，读取的指令进入指令缓冲器
>   2. ip = ip + 所读取指令的长度，从而指向下一条指令
>   3. 执行指令，转到步骤1，重复这个过程
>
>   ![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F202003%2F20200311122741999752.png&refer=http%3A%2F%2Fimage.mamicode.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1654167346&t=001c864e7062a9f4e0de715419843679)

- 8086cpu机器刚上电

> 在8086cpu加电启动或复位后，cs和ip被设置为cs = FFFFH，ip = 0000H
>
> 即在机器刚启动时，cpu从物理地址FFFF0H单元中读取指令执行。
>
> FFFF0H单元中的指令是8086cpu开机后执行的第一条指令。
>
> 如果说内存中一段信息曾经被cpu执行，那么它所在的内存单元必然被cs:ip指向过。

- jmp

> 如何修改ax中的值
>
> mov ax, 123
>
> mov指令可以改变大部分8086cpu大部分寄存器的值，被称为传送指令
>
> 但mov不能改变cs、ip的值，8086cpu没有提供这样的功能
>
> 同时修改cs、ip中的内容
>
> jmp段地址:偏移地址
> jmp 2AE3:3
> jmp 3:0B16
>
> 功能：用指令中给出的段地址修改cs，偏移地址修改ip
>
> - 仅修改IP的内容
>
>     jmp 某一合法寄存器
>
>     例如：
>
>     jmp ax(类似于mov IP, ax)
>
>     jmp bx

- 代码段

>对于8086pc机，在编程时，可以根据需要，将一组内存单元定义为一个段
>
>可以将长度为N（N <= 64KB，偏移地址不超过16位）的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。
>
>mov ax, 0000 (B8 00 00)
>add ax, 0123 (05 23 01)
>mov bx, ax (8B D8)
>jmp bx (FF E3)
>
>这段长度为10字节的字节指令，存在从123B0H ~ 123B9H的一组内存单元中，我们就可以认为，123B0H ~ 123B9H这段单元内存是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10字节。

- 小结

> 1. 段地址在8086cpu的寄存器中存放，当8086cpu要访问内存时，由段寄存器提供内存单元的段地址，8086cpu有4个段寄存器，其中cs用来存放指令。
> 2. cs存放指令的段地址，IP存放指令的偏移地址。
> 3. 8086机中，任意时刻，cpu将cs:ip指向的内容当作指令执行。
> 4. 8086cpu的工作过程
>    1. 从cs:ip指向内存单元读取指令，读取的指令进入指令缓冲器
>    2. ip指向下一条指令
> 5. 8086cpu提供转移指令(jmp)，修改cs、ip的内容。

### DS和[address]

> 8086cpu中有一个DS寄存器，通常用来存放要访问的数据的段地址

- 读取10000H单元的内容

  mov bx, 1000H
  mov ds, bx
  mov al, [0] // 将内存单元中的数据，送入寄存器

  上述三条指令，将10000H(1000:0)中的数据读到al中。

> 执行指令时，8086cpu自动取ds中的数据作为内存单元的段地址

- 如何用mov指令从10000H中读取数据？

  1. 10000H表示为1000:0
  2. 将段地址1000H放入ds
  3. 用mov al, [0] （mov指令中的[说明]操作对象是一个内存单元，[]中的0说明这个内存单元的偏移地址是0，它的段地址默认放在ds中）

- 能不能把1000H送入ds？不能

  mov ax, 1 ✔

  mov ds, 1000H ×

  8086cpu不支持将数据直接送入段寄存器，ds是一个段寄存器（硬件设计的问题）

  所以mov ds, 1000H是非法的

  应该：数据 -> 通用寄存器 -> 段寄存器

- 怎么把数据从寄存器送入内存单元？

  mov bx, 1000H
  mov ds, bx
  mov [0], al // 把ax低八位数据送入内存1000:0

> 对于8086cpu，我们可以将一组内存单元定义为一个段（可以是代码段、数据段等）
>
> 我们可以将一组长度为N（N <= 64K）、地址连续、起始地址为16倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段

### 字的传送

> 因为8086cpu是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是说一次性传送一个字
>
> mov bx, 1000H
> mov ds, bx
> mov ax, [0] // 1000:0处的字节型数据送入ax
> mov [0], cx // cx中的16位数据送入1000:0处

### mov、sub、sub指令

> - mov
>
>   mov 寄存器, 数据
>   mov 寄存器, 寄存器
>   mov 寄存器, 内存单元
>   mov 内存单元, 寄存器
>   mov 段寄存器, 寄存器
>
> - add
>
>   add 寄存器, 数据
>   add 寄存器, 寄存器
>   add 寄存器, 内存单元
>   add 内存单元, 寄存器
>
> - sub
>
>   sub 寄存器, 数据
>   sub 寄存器, 寄存器
>   sub 寄存器, 内存单元
>   sub 内存单元, 寄存器

### cpu提供的栈机制

8086cpu提供入栈和出栈指令：
push（入栈）
pop（出栈）

push ax ：将寄存器ax中的数据送入栈中
pop ax ：从栈顶取出数据送入ax

8086cpu的入栈和出栈操作都是以字为单位进行的（2个字节）

- 例：我们可以将10000H ~ 1000FH这段内存当作栈来使用

  mov ax, 0123H
  push ax
  mov bx, 2266H
  push bx
  mov cx, 1122H
  push cx
  pop ax
  pop bx
  pop cx

- Q：CPU如何知道当前要执行的指令所在的位置？

  A：寄存器CS和IP中存放着当前指令的段地址和偏移地址

  8086CPU中，有两个寄存器：

  段寄存器SS：存放栈顶的段地址

  寄存器IP：存放栈顶的偏移地址

  任意时刻，SS:IP指向栈顶元素

- push ax背后的原理

  1. sp = sp - 2（栈顶指针移动）
  2. 将ax中的内容送入ss:sp指向的内存单元处，ss:sp此时指向新栈顶

- Q：初始状态下，sp指向哪里？

  ![](https://ss1.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/caef76094b36acaf37d9ffaa7dd98d1001e99cae.jpg)

  A：SP = 0010H，即如果有第一个数据入栈，则SP = 000EH（0010H - 0002H），也就是说初始状态，栈顶指针指向最高地址单元的下一个单元

- 小结

  任意时刻，ss:sp指向栈顶元素，当栈为空时，栈中没有元素，也就不存在栈顶元素。

  所以当ss:sp只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2

  栈最底部字单元的地址为1000:000E，所以栈空时sp = 0010H

- pop ax

  1. 将ss:sp指向的内存单元处的数据送入ax中
  2. sp = sp + 2，ss:sp指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶

  出栈之后，ss:sp指向新的栈顶

  1000EH，pop操作前的栈顶元素
  1000CH处的2266H依然存在，但是它已经不在栈中。（即pop只是栈顶指针的移动，数据还会存在，逻辑上数据不存在）

- pop、push 内存单元

  例：

  push [0] // 自动找到段寄存器ds存放的段地址 + 偏移地址[0]，找到里面的字型数据，push入栈中
  pop [2] // 把栈顶元素pop入ds存放的段地址 + 偏移地址[2]

  

### 栈顶越界问题

- 当栈满的是，再使用push指令会发生什么

  A：栈顶越界

  栈顶越界是危险的，有可能覆盖其他程序的指令，CPU并不知道栈顶栈底在哪里

### 一个源程序从写出到执行的过程

> 编写 -> 编译 -> 连接 -> 执行
>
> 编译：使用编译程序对源文件中的源程序进行编译，产生目标文件
>
> 连接：对目标文件进行连接，生成可在操作系统中直接运行的可执行文件

- 可执行文件包括两个部分
  1. 程序，从源程序翻译过来的机器码和源程序中的数据
  2. 相关的描述信息，比如程序有多大，要占用多少内存空间等

### [BX]

- [bx]

  [bx]表示一个内存单元，它的偏移地址在bx中

  比如：

  mov ax, [bx]
  mov al, [bx]

- 描述性符号()

  1. ax中的内容为0010H，可以描述为(ax) = 0010H
  2. 2000:1000处的内容为0010H，可以描述为(21000H) = 0010H
  3. 对于mov ax, [2]的功能，可以这样描述(ax) = ((ds) * 16 + 2)
  4. 对于mov [2], ax的功能，可以描述为((ds) * 16 + 2) = (ax) 
  5. 对于add ax, 2的功能，可以描述为(ax) = (ax) + 2
  6. 对于add ax, bx的功能，可以描述为(ax) = (ax) + (bx)
  7. 对于push ax的功能，可以描述为(sp) = (sp) - 2，((ss) * 16 + (sp)) = (ax)
  8. 对于pop ax的功能，可以描述为(ax) = ((ss) * 16 + (sp))，(sp) = (sp) + 2 

- idata

  idata表示常量，比如mov ax, [idata]，即可以是mov ax, [0]，mov ax, [1]等。

- mov ax, [bx]

  功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA出的数据送入ax中。

  即：(ax) = (ds * 16 + (bx))

- mov [bx], ax

  功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将ax中的数据送入内存SA:EA处

  即：(ds * 16 + (bx)) = (ax)

### LOOP指令

> 指令的格式是：loop标号，CPU执行loop指令的时候，要进行两部操作
>
> 1. (cx) = (cx) - 1
> 2. 判断cx中的值，不为零则转至标号处执行程序，否则向下执行
>
> 通常，我们用loop指令来实现循环功能，cx中存放循环次数
>
> - 格式
>
>   用cx和loop指令配合
>
>   ```asm
>     mov cx, 循环次数
>   s:循环执行的程序段
>     loop s
>   ```

- 编程计算2^12，结果放入ax中

  ```asm
    mov ax, 2
    mov cx, 11
  s:add ax, ax
    loop s
  ```

  cx表示循环次数，s是标号可以任意命名

- 用加法计算123 * 236，结果存在ax中

  ```asm
     mov ax, 0 
     mov cx, 236
  s: add ax, 123
     loop s // 123相加了236次
  ----------------------
     mov ax, 0 
     mov cx, 123
  s: add ax, 236 // 236相加123次
     loop s
  ```

### dw

> dw ：define word，即定义字型。
>
> 以此类推，db ： define byte

- demo

  ```asm
  assume cs : codesg
  	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
  	mov bx, 0
  	mov ax, 0
  	mov cx, 0
  s:  add ax, cs:[bx]
  	add bx, 2
  	loop s
  	mov ax, 4c00h
  	int 21h
  codesg ends
  end
  ```

  这段程序的意思是，把dw中的八个数据相加，结果存在ax寄存器

  可是，这八个数据是存放在哪里的？

  答：段地址cs，因为这些数据定义在cs（code segment）。偏移地址从0开始，依次+2。

  所以结果是：CS:0，CS:2，......CS:E

### 增加程序入口

> 这里增加start，标明程序的入口。start可以改为任意单词。

- demo

  ```asm
  assume cs : codesg
  	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
  start:
  	mov bx, 0
  	mov ax, 0
  	mov cx, 0
  s:  
  	add ax, cs:[bx]
  	add bx, 2
  	loop s
  	mov ax, 4c00h
  	int 21h
  codesg ends
  end start // end除了通知编译器程序结束之外，还可以通知编译器程序的入口在哪里
  ```

- cpu如何知道去执行它们？

  我们在源程序最后使用"end start"说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，cpu的cs:ip就被设置指向这个入口，从而开始执行程序中的第一条指令。

  标号"start"在"code"段中，这样cpu就将code段中的内容当作指令来执行了。

### and指令和or指令

- or

> or指令：逻辑或指令，按位进行或运算
>
> 如: 
> mov al, 01100011B
> or al, 00111011B
> 执行后：al = 01111011B

- and

> and指令：逻辑与指令，按位进行与运算
>
> 如：
> mov al, 01100011B
> and al, 00111011B
> 执行后：al = 00100011B
