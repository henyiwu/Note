[toc]

## 汇编语言

### linux安装nasm环境

> 1. sudo apt-get install nasm
>
> 2. 创建.asm文件	
>
> 3. 64位
>
>    nasm -f elf64 -g -F stabs helloworld.asm -o helloworld.o // 编译
>
>    ld -o helloworld helloworld.o // 链接
>
>    32位
>
>    nasm -f elf -g -F stabs helloworld.asm -o helloworld.o
>
>    ld -m elf_i386 -o helloworld helloworld.o
>
> 4. 运行./hello

### 16位结构的cpu

> 概括地讲，一个16位的cpu具有一下几个方面的特征
>
> 1. 运算器（ALU）一次最多可以处理16为的数据
> 2. 寄存器的最大宽度为16位
> 3. 寄存器和运算器之间的通路是16位的

### 8086cpu给出物理地址的方法(物理地址 = 段地址 * 16 + 偏移地址)

> 8086有20位地址总线，可传送20位地址数据，寻址能力为1M，2^20*8bit(8086一个存储单元的容量为8bit) = 1M
>
> 8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力只有64k
>
> 8086cpu采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址（通过地址加法器）
>
> ![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fvanie%2F201103%2F201103030220052921.jpg&refer=http%3A%2F%2Fimages.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1654155294&t=716088c10c40ea642801a286d43dae74)
>
> 地址加法器合成物理地址的方法：物理地址 = 段地址 * 16 + 偏移地址
>
> ![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F2018969-fd967f2e9eec4d5c.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1654155472&t=6030ee30500f5817e8328d1175eba410)
>
> - 物理地址 = 段地址 * 16 + 偏移地址 —— 本质含义
>
>   比喻：比如说学校、体育馆同在一条笔直的单行路上（学校位于路的起点0米处）
>
>   我在学校，要去图书馆，问我那里的地址，我可以用几种方式描述这个地址？
>
>   ————————————————————————————————
>   |																	|											|
>
>   0m（学校）												2000m（体育馆）				2826m(图书馆)
>
>   1) 从学校走2826m到图书馆，这2826m可以认为是图书馆的物理地址
>
>   2) 从学校走2000m到体育馆，从体育馆走826m到图书馆
>
>      第一个距离2000m是相对于起点的基础地址
>
>      第二个距离826m是将对于基础地址的偏移地址

### 寄存器概述

> 8086cpu有14个寄存器，它们的名称为：ax、bx、cx、dx、si、di、sp、bp、ip、cs、ss、ds、es、psw
>
> - 通用寄存器
>
>   8086cpu所有的寄存器都是16位的，可以存放两个字节
>
> 数据18
> 二进制表示10010
> 在寄存器ax中存储：
>
> | 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
> | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    | 1    | 0    |
>
> 一个16位寄存器能存储的最大的数值：2^16-1
>
> 8086上一代的cpu中的寄存器都是8位的，为保证兼容性，这四个寄存器都可以分为两个独立8位的寄存器使用
>
> ax可以分为ah和al
> bx可以分为bh和bl
> cx可以分为ch和cl
> dx可以分为dh和dl

### 几条汇编指令

> | 汇编指令   | 控制cpu完成的操作                  | 用高级语言的语法描述 |
> | ---------- | ---------------------------------- | -------------------- |
> | mov ax, 18 | 将18送入ax                         | ax = 18              |
> | mav ah, 78 | 将78送入ah                         | ah = 78              |
> | add ax, 8  | 将寄存器ax中的数值+8               | ax = ax + 8          |
> | mov ax, bx | 将寄存器bx中的数据送入ax寄存器     | ax = bx              |
> | add ax, bx | 将ax, bx中的内存相加，结果存在ax中 | ax = ax + bx         |
>
> add ax, bx // ax = 8226h, bx = 8226h
> ax = 044ch // 结果应该是1044ch，但一个寄存器只能存16位数据，所以这个1被进位了

### 段的概念

> 若干连续的内存单元可以看作一个段，用段地址 * 16定位段的起始地址，用偏移地址定位段中的内存单元
>
> 1. 段地址 * 16 必然是16的倍数，所以一个段地址的起始地址一定也是16的倍数
> 2. 偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k

### 内存单元地址

> CPU访问内存单元时，必须向内存提供内存单元的物理地址。
>
> 8086cpu内存用段地址和偏移地址移位相加的方法形成了最终的物理地址。
>
> 观察以下地址
>
> | 物理地址 | 段地址 | 偏移地址 |
> | -------- | ------ | -------- |
> | 21F60H   | 2000H  | 1F60H    |
> |          | 2100H  | 0F60H    |
> |          | 21F0H  | 0060H    |
>
> 结论：cpu可以用不同的段地址和偏移地址形成同一个物理地址。
>
> Q：如果给定一个段地址，又通过变化偏移地址进行寻址，最多可以定位多少内存单元?
> A：偏移地址16位，变化范围为0~FFFFH，仅通过偏移地址来寻址最多可以寻64K个内存单元
>
> 在8086pc机中，存储单元的地址用两个元素来描述，即段地址和偏移地址
> “数据在21F60H内存单元中。”对于8086pc机的两种描述
>
> 1. 数据在内存2000:1F60单元中
> 2. 数据在内存2000段的1F60H单元中
>
> 可根据需要，将地址连续，起始地址为16的倍数的一组内存单元定义为一个段

### 段寄存器

> 段寄存器就是提供段地址的
>
> 8086cpu有4个段寄存器：cs（code  segment ）、ds（data segment）、ss（stack segment）、es（extra segment）
>
> 当8086cpu要访问内存时，由这4个段寄存器提供内存单元的段地址

- CS和IP

> CS和IP是8086CPU中最关键的寄存器，它们指示了cpu当前要读取指令的地址
>
> CS：代码段寄存器
> IP：指令指针寄存器
>
> - 8086pc工作过程的简要描述
>
>   1. 从cs:ip指向内存单元读取指令，读取的指令进入指令缓冲器
>   2. ip = ip + 所读取指令的长度，从而指向下一条指令
>   3. 执行指令，转到步骤1，重复这个过程
>
>   ![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F202003%2F20200311122741999752.png&refer=http%3A%2F%2Fimage.mamicode.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1654167346&t=001c864e7062a9f4e0de715419843679)

- 8086cpu机器刚上电

> 在8086cpu加电启动或复位后，cs和ip被设置为cs = FFFFH，ip = 0000H
>
> 即在机器刚启动时，cpu从物理地址FFFF0H单元中读取指令执行。
>
> FFFF0H单元中的指令是8086cpu开机后执行的第一条指令。
>
> 如果说内存中一段信息曾经被cpu执行，那么它所在的内存单元必然被cs:ip指向过。

- jmp

> 如何修改ax中的值
>
> mov ax, 123
>
> mov指令可以改变大部分8086cpu大部分寄存器的值，被称为传送指令
>
> 但mov不能改变cs、ip的值，8086cpu没有提供这样的功能
>
> 同时修改cs、ip中的内容
>
> jmp段地址:偏移地址
> jmp 2AE3:3
> jmp 3:0B16
>
> 功能：用指令中给出的段地址修改cs，偏移地址修改ip
>
> - 仅修改IP的内容
>
>   jmp 某一合法寄存器
>
>   例如：
>
>   jmp ax(类似于mov IP, ax)
>
>   jmp bx

- 代码段

>对于8086pc机，在编程时，可以根据需要，将一组内存单元定义为一个段
>
>可以将长度为N（N <= 64KB，偏移地址不超过16位）的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段。
>
>mov ax, 0000 (B8 00 00)
>add ax, 0123 (05 23 01)
>mov bx, ax (8B D8)
>jmp bx (FF E3)
>
>这段长度为10字节的字节指令，存在从123B0H ~ 123B9H的一组内存单元中，我们就可以认为，123B0H ~ 123B9H这段单元内存是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10字节。

- 小结

> 1. 段地址在8086cpu的寄存器中存放，当8086cpu要访问内存时，由段寄存器提供内存单元的段地址，8086cpu有4个段寄存器，其中cs用来存放指令。
> 2. cs存放指令的段地址，IP存放指令的偏移地址。
> 3. 8086机中，任意时刻，cpu将cs:ip指向的内容当作指令执行。
> 4. 8086cpu的工作过程
>    1. 从cs:ip指向内存单元读取指令，读取的指令进入指令缓冲器
>    2. ip指向下一条指令
> 5. 8086cpu提供转移指令(jmp)，修改cs、ip的内容。

