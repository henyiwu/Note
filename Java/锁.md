[toc]

## 锁

### Synchronized

> 给一个对象上锁，即修改一个对象的**Mark Words**

- 一段并发代码

  ```java
  public static void main(String[] args) throws InterruptedException {
      Thread[] threads = new Thread[100];
      CountDownLatch latch = new CountDownLatch(threads.length);
      for (int i = 0; i < threads.length; i++) {
          threads[i] = new Thread(() -> {
              for (int j = 0; j < 10000; j++) {
                  m++;
              }
              latch.countDown();
          });
      }
  
      Arrays.stream(threads).forEach((t) -> t.start());
  
      latch.await();
  
      System.out.println(m);
  }
  
  输出：525961
  ```

- 加上synchronized

  ```java
  static Object object = new Object();
  
  public static void main(String[] args) throws InterruptedException {
      Thread[] threads = new Thread[100];
      CountDownLatch latch = new CountDownLatch(threads.length);
      for (int i = 0; i < threads.length; i++) {
          threads[i] = new Thread(() -> {
              for (int j = 0; j < 10000; j++) {
                  synchronized (object) {
                      m++;
                  }
              }
              latch.countDown();
          });
      }
  
      Arrays.stream(threads).forEach((t) -> t.start());
  
      latch.await();
  
      System.out.println(m);
  }
  
  输出：1000000
  ```

- 或者使用atomicInteger

  ```java
  private static volatile AtomicInteger atomicInteger = new AtomicInteger(0);
  
  static Object object = new Object();
  
  public static void main(String[] args) throws InterruptedException {
      Thread[] threads = new Thread[100];
      CountDownLatch latch = new CountDownLatch(threads.length);
      for (int i = 0; i < threads.length; i++) {
          threads[i] = new Thread(() -> {
              for (int j = 0; j < 10000; j++) {
                  atomicInteger.incrementAndGet();
              }
              latch.countDown();
          });
      }
  
      Arrays.stream(threads).forEach((t) -> t.start());
  
      latch.await();
  
      System.out.println(atomicInteger.get());
  }
  ```

### CAS

> Compare and Swap
>
> 有一个静态变量，初始值为0。
> 两个线程读写同一个变量，线程1读变量a，并把变量a++变为1
> 线程2也读变量a，并把变量a++变为2，
>
> 线程1写回变量，发现变量还是0，则赋值a=1。
> 线程2写回变量，发现变量是1，则重新获取变量a=1，a++，变为变量2，写回时发现a=1，则赋值a=2

#### CAS的ABA问题

> 即线程写回值时虽然发现值未改变，但很可能该值已经被改变过n次但结果没变
>
> 例如：线程1读取变量a=0
> 线程2读取变量a=0，改为a=100，写回
> 线程3读取变量a=100，改为a=0写回
> 此时线程1再写回，发现变量a=0，但其实变量已经被多次修改过
>
> 解决办法，加版本号

### CAS如何保证原子性问题

- asm

  ```
  lock cmpxchg 指令
  
  cmpxchg : compare and exchange
  lock : 执行后面这条指令(cmpxchg)时，把总线锁住，让当前cpu使用，其他cpu不能使用
  
  只有多核cpu才需要加cmpxchg，否则只需要cmpxchg既可保证cas的原子性

### 锁升级过程

> 系统怎么知道需要锁升级：jvm判断有多线程执行时进行锁升级，即jvm知道当前有几个线程在执行临界区代码
>
> 早期jdk版本的synchronized只有重量级锁
>
> 为什么时候锁升级：只要有线程来抢执行权，就进行锁升级
>
> 锁从轻到重：没有锁的状态 -> 偏向锁 -> 自旋锁 -> 重量级锁状态
>
> 1. 没有锁：正常执行代码
>
> 2. 偏向锁：并发时，第一个到达临界区的线程，这把锁偏向它。（**为什么需要有偏向锁：实际运行中，许多加了锁的代码块，也只有一个线程在运行，例如hashtable、stringbuffer，如果每次访问都加锁，效率过低**）
>
> 3. 自旋锁（轻量级锁）：cas
> 4. 重量级锁：自旋次数过多、线程过多都会导致锁升级

### Q&A

> Q：请描述synchronized和reentrantlock的底层实现及重入的底层原理
>
> Q：请描述锁的四种状态和升级过程
>
> Q：CAS的ABA问题如何解决
>
> Q：请谈一下AQS，为什么AQS的底层原理是CAS + volatile
>
> Q：volatile的可见性和禁止指令重排序是如何实现的
>
> Q：CAS是什么
>
> Q：请描述一下对象的创建过程
>
> Q：对象在内存中的内存布局
>
> Q：DCL单例为什么要加volatile
>
> Q：Object o = new Object()在内存中占了几个字节
>
> A：16bytes
>
> Q：请描述synchronized和reentrantlock的异同
>
> Q：请描述一下锁的分类以及在JDK中的应用
>
> Q：自旋锁效率一定比重量级锁的效率高吗
>
> Q：打开偏向锁是否效率一定会提升
